

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PyOCN.ocn &mdash; PyOCN 1.2.20251010 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=98efb7dd"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            PyOCN
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PyOCN</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">PyOCN.ocn</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for PyOCN.ocn</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">ctypes</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">os</span><span class="w"> </span><span class="kn">import</span> <span class="n">PathLike</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numbers</span><span class="w"> </span><span class="kn">import</span> <span class="n">Number</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span> 
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">._statushandler</span><span class="w"> </span><span class="kn">import</span> <span class="n">check_status</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">simulated_annealing_schedule</span><span class="p">,</span> <span class="n">net_type_to_dag</span><span class="p">,</span> <span class="n">unwrap_digraph</span><span class="p">,</span> <span class="n">assign_subwatersheds</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">_libocn_bindings</span> <span class="k">as</span> <span class="n">_bindings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">_flowgrid_convert</span> <span class="k">as</span> <span class="n">fgconv</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">High-level Optimized Channel Network (OCN) interface.</span>

<span class="sd">This module provides a high-level interface to the underlying</span>
<span class="sd">``libocn`` C library. The :class:`OCN` class can be used for </span>
<span class="sd">constructing and optimizing river network models using </span>
<span class="sd">simulated annealing.</span>

<span class="sd">Notes</span>
<span class="sd">-----</span>
<span class="sd">- The underlying data structure managed by :class:`OCN` is a FlowGrid owned by</span>
<span class="sd">    ``libocn``. Pointer lifetime and destruction are handled safely within this</span>
<span class="sd">    class.</span>
<span class="sd">- Many operations convert to a NetworkX ``DiGraph`` for convenience. These</span>
<span class="sd">    conversions are slow, and are intended for inspection, analysis, </span>
<span class="sd">    and visualization rather than tight inner loops.</span>

<span class="sd">See Also</span>
<span class="sd">--------</span>
<span class="sd">PyOCN.utils</span>
<span class="sd">        Helper functions for OCN fitting and construction</span>
<span class="sd">PyOCN.plotting</span>
<span class="sd">        Helper functions for visualization and plotting</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">#TODO: have to_rasterio use the option to set the root node to 0,0 by using to_xarray as the backend instead of numpy?</span>


<div class="viewcode-block" id="OCN">
<a class="viewcode-back" href="../../index.html#PyOCN.OCN">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">OCN</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The main class for interacting with Optimized Channel Networks. </span>

<span class="sd">    Use :meth:`OCN.from_net_type` or :meth:`OCN.from_digraph` to construct an</span>
<span class="sd">    instance. </span>
<span class="sd">    </span>
<span class="sd">    Constructor Methods</span>
<span class="sd">    -------------------</span>
<span class="sd">    :meth:`from_net_type`</span>
<span class="sd">        Create an OCN from a predefined network type and dimensions.</span>
<span class="sd">    :meth:`from_digraph`</span>
<span class="sd">        Create an OCN from an existing NetworkX DiGraph.</span>

<span class="sd">    Export Methods</span>
<span class="sd">    --------------</span>
<span class="sd">    :meth:`to_digraph`</span>
<span class="sd">        Export the current grid to a NetworkX DiGraph.</span>
<span class="sd">    :meth:`to_numpy`</span>
<span class="sd">        Export raster arrays (energy, drained area, watershed_id) as numpy arrays.</span>
<span class="sd">    :meth:`to_xarray`</span>
<span class="sd">        Export raster arrays as an xarray Dataset (requires xarray).</span>
<span class="sd">    :meth:`to_gtiff`</span>
<span class="sd">        Export raster arrays to a GeoTIFF file (requires rasterio).</span>
<span class="sd">    :meth:`copy`</span>
<span class="sd">        Create a deep copy of the OCN.</span>

<span class="sd">    Optimization Methods</span>
<span class="sd">    --------------------</span>
<span class="sd">    :meth:`single_erosion_event`</span>
<span class="sd">        Perform a single erosion event at a given temperature.</span>
<span class="sd">    :meth:`fit`</span>
<span class="sd">        Optimize the network using the simulated annealing method from Carraro et al (2020).</span>
<span class="sd">    :meth:`fit_custom_cooling`</span>
<span class="sd">        Optimize the network using a custom cooling function.</span>

<span class="sd">    Other methods</span>
<span class="sd">    -------------</span>
<span class="sd">    :meth:`compute_energy`</span>
<span class="sd">        Compute the current energy of the network.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    energy : float</span>
<span class="sd">        Current energy of the network (read-only property).</span>
<span class="sd">    dims : tuple[int, int]</span>
<span class="sd">        Grid dimensions (rows, cols) of the FlowGrid (read-only property).</span>
<span class="sd">    resolution: float</span>
<span class="sd">        The side length of each grid cell (read-only property).</span>
<span class="sd">    nroots : int</span>
<span class="sd">        Number of root nodes in the current OCN grid (read-only property).</span>
<span class="sd">    gamma : float</span>
<span class="sd">        Exponent in the energy model.</span>
<span class="sd">    master_seed : int</span>
<span class="sd">        The seed used to initialize the internal RNG.</span>
<span class="sd">    verbosity : int</span>
<span class="sd">        Verbosity level for underlying library output (0-2).</span>
<span class="sd">    wrap : bool</span>
<span class="sd">        If true, enables periodic boundary conditions on the FlowGrid (read-only property).</span>
<span class="sd">    history : np.ndarray</span>
<span class="sd">        numpy array of shape (n_iterations, 3) recording the iteration index, energy, and temperature at each iteration during optimization.</span>
<span class="sd">        Updated each time an optimization method is called.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The following is a simple example of creating, optimizing, and plotting</span>
<span class="sd">    an OCN using PyOCN and Matplotlib. More examples are available in the</span>
<span class="sd">    `demo.ipynb` notebook in the repository (https://github.com/alextsfox/PyOCN).</span>

<span class="sd">    &gt;&gt;&gt; # Fit an OCN from a &quot;Hip-roof&quot; initial network shape and periodic boundary conditions</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib as mpl</span>
<span class="sd">    &gt;&gt;&gt; import PyOCN as po</span>
<span class="sd">    &gt;&gt;&gt; ocn = po.OCN.from_net_type(&quot;H&quot;, dims=(64, 64), wrap=True, random_state=8472, verbosity=0)</span>
<span class="sd">    &gt;&gt;&gt; ocn.fit()</span>
<span class="sd">    &gt;&gt;&gt; po.plot_ocn_raster(ocn, norm=mpl.colors.PowerNorm(gamma=0.5), attribute=&#39;drained_area&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dag</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">,</span> <span class="n">resolution</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbosity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">validate</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">wrap</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct an :class:`OCN` from a valid NetworkX ``DiGraph``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Please use the classmethods :meth:`OCN.from_net_type` or</span>
<span class="sd">        :meth:`OCN.from_digraph` to instantiate an OCN.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># validate gamma, annealing schedule, and random_state</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">Number</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;gamma must be a scalar. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">gamma</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;gamma values outside of [0, 1] may not be physically meaningful. Got </span><span class="si">{</span><span class="n">gamma</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">resolution</span><span class="p">,</span> <span class="n">Number</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;resolution must be numeric. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">resolution</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">=</span> <span class="n">verbosity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__p_c_graph</span> <span class="o">=</span> <span class="n">fgconv</span><span class="o">.</span><span class="n">from_digraph</span><span class="p">(</span>  <span class="c1"># does most of the work </span>
            <span class="n">dag</span><span class="p">,</span> 
            <span class="n">resolution</span><span class="p">,</span> 
            <span class="n">verbose</span><span class="o">=</span><span class="p">(</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">),</span> 
            <span class="n">validate</span><span class="o">=</span><span class="n">validate</span><span class="p">,</span> 
            <span class="n">wrap</span><span class="o">=</span><span class="n">wrap</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rng</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__p_c_graph</span><span class="o">.</span><span class="n">contents</span><span class="o">.</span><span class="n">energy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_energy</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

<div class="viewcode-block" id="OCN.from_net_type">
<a class="viewcode-back" href="../../index.html#PyOCN.OCN.from_net_type">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_net_type</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">net_type</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">resolution</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">gamma</span> <span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbosity</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">wrap</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an :class:`OCN` from a predefined network type and dimensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        net_type : str</span>
<span class="sd">            Predefined network type to instantiate from. Valid types are &quot;H&quot;, &quot;I&quot;, &quot;E&quot;, and &quot;V&quot;. See</span>
<span class="sd">            :func:`~PyOCN.utils.net_type_to_dag` for more information.</span>
<span class="sd">        dims : tuple[int, int]</span>
<span class="sd">            Grid dimensions (rows, cols). Both must be positive even integers.</span>
<span class="sd">        resolution : int, optional</span>
<span class="sd">            The side length of each grid cell.</span>
<span class="sd">        gamma : float, default 0.5</span>
<span class="sd">            Exponent in the energy model.</span>
<span class="sd">        random_state : int | numpy.random.Generator | None, optional</span>
<span class="sd">            Seed or generator for RNG seeding.</span>
<span class="sd">        verbosity : int, default 0</span>
<span class="sd">            Verbosity level (0-2) for underlying library output.</span>
<span class="sd">        wrap : bool, default False</span>
<span class="sd">            If true, allows wrapping around the edges of the grid (toroidal). If false, no wrapping is applied.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        OCN</span>
<span class="sd">            A newly constructed instance initialized from the specified</span>
<span class="sd">            network type and dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dims must be a tuple of two positive integers, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> 
            <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dims must be a tuple of two positive integers, got </span><span class="si">{</span><span class="n">dims</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">verbosity</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Creating </span><span class="si">{</span><span class="n">net_type</span><span class="si">}</span><span class="s2"> network DiGraph with dimensions </span><span class="si">{</span><span class="n">dims</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="n">net_type_to_dag</span><span class="p">(</span><span class="n">net_type</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbosity</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; Done.&quot;</span><span class="p">)</span>
        
        <span class="c1"># no need to validate inputs when using a predefined net_type. Saves time.</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">dag</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="n">verbosity</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="n">wrap</span><span class="p">)</span></div>


<div class="viewcode-block" id="OCN.from_digraph">
<a class="viewcode-back" href="../../index.html#PyOCN.OCN.from_digraph">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_digraph</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dag</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">,</span> <span class="n">resolution</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbosity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wrap</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an :class:`OCN` from an existing NetworkX ``DiGraph``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dag : nx.DiGraph</span>
<span class="sd">            Directed acyclic graph (DAG) representing the stream network.</span>
<span class="sd">        resolution : int, optional</span>
<span class="sd">            The side length of each grid cell.</span>
<span class="sd">        gamma : float, default 0.5</span>
<span class="sd">            Exponent in the energy model.</span>
<span class="sd">        random_state : int | numpy.random.Generator | None, optional</span>
<span class="sd">            Seed or generator for RNG seeding.</span>
<span class="sd">        verbosity : int, default 0</span>
<span class="sd">            Verbosity level (0-2) for underlying library output.</span>
<span class="sd">        wrap : bool, default False</span>
<span class="sd">            If true, allows wrapping around the edges of the grid (toroidal). If false, no wrapping is applied.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        OCN</span>
<span class="sd">            A newly constructed instance encapsulating the provided graph.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The input graph must satisfy all of the following:</span>

<span class="sd">        - It is a directed acyclic graph (DAG).</span>
<span class="sd">        - Each node has attribute ``pos=(row:int, col:int)`` specifying its</span>
<span class="sd">          grid position with non-negative coordinates. Any other attributes</span>
<span class="sd">          are ignored.</span>
<span class="sd">        - The graph can be partitioned into one or more spanning trees over </span>
<span class="sd">          a dense grid of shape ``(m, n)``: each grid cell corresponds to </span>
<span class="sd">          exactly one node; each non-root node has ``out_degree == 1``; </span>
<span class="sd">          the roots have ``out_degree == 0``.</span>
<span class="sd">        - Edges connect only to one of the 8 neighbors (cardinal or diagonal),</span>
<span class="sd">          i.e., no jumps over rows or columns. If ``wrap=True``, edges may</span>
<span class="sd">          connect across the grid boundaries (i.e. row 0 can connect to row m-1 and col 0 can connect to col n-1).</span>
<span class="sd">        - Edges do not cross in the row-column plane.</span>
<span class="sd">        - Both ``m`` and ``n`` are positive integers, and there are at least four</span>
<span class="sd">          vertices.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # creating a &quot;zig-zag&quot; network</span>
<span class="sd">        &gt;&gt;&gt; # O O O O</span>
<span class="sd">        &gt;&gt;&gt; # |/|/|/|</span>
<span class="sd">        &gt;&gt;&gt; # O O O X</span>
<span class="sd">        &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">        &gt;&gt;&gt; import PyOCN as po</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib as mpl</span>
<span class="sd">        &gt;&gt;&gt; dag = nx.DiGraph()</span>
<span class="sd">        &gt;&gt;&gt; for i in range(8):</span>
<span class="sd">        ...     dag.add_node(i, pos=(i % 4, i // 4))</span>
<span class="sd">        ...     if i &lt; 7: dag.add_edge(i, i + 1)</span>
<span class="sd">        &gt;&gt;&gt; ocn = OCN.from_digraph(dag, random_state=8472)</span>
<span class="sd">        &gt;&gt;&gt; ocn.fit()</span>
<span class="sd">        &gt;&gt;&gt; po.plot_ocn_raster(ocn, norm=mpl.colors.PowerNorm(gamma=0.5), attribute=&#39;drained_area&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">dag</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="n">verbosity</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="n">wrap</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#TODO: too verbose?</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;PyOCN.OCN object at 0x</span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">:</span><span class="s2">x</span><span class="si">}</span><span class="s2"> with FlowGrid_C at 0x</span><span class="si">{</span><span class="n">ctypes</span><span class="o">.</span><span class="n">addressof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__p_c_graph</span><span class="o">.</span><span class="n">contents</span><span class="p">)</span><span class="si">:</span><span class="s2">x</span><span class="si">}</span><span class="s2"> and Vertex_C array at 0x</span><span class="si">{</span><span class="n">ctypes</span><span class="o">.</span><span class="n">addressof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__p_c_graph</span><span class="o">.</span><span class="n">contents</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span><span class="si">:</span><span class="s2">x</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;OCN(gamma=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="si">}</span><span class="s2">, energy=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">energy</span><span class="si">}</span><span class="s2">, dims=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="si">}</span><span class="s2">, resolution=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="si">}</span><span class="s2">m, verbosity=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span><span class="si">}</span><span class="s2">)&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_bindings</span><span class="o">.</span><span class="n">libocn</span><span class="o">.</span><span class="n">fg_destroy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__p_c_graph</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__p_c_graph</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__sizeof__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span><span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">object</span><span class="o">.</span><span class="n">__sizeof__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="o">.</span><span class="n">__sizeof__</span><span class="p">()</span> <span class="o">+</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__history</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">+</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">sizeof</span><span class="p">(</span><span class="n">_bindings</span><span class="o">.</span><span class="n">FlowGrid_C</span><span class="p">)</span> <span class="o">+</span> 
            <span class="n">ctypes</span><span class="o">.</span><span class="n">sizeof</span><span class="p">(</span><span class="n">_bindings</span><span class="o">.</span><span class="n">Vertex_C</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;OCN&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a deep copy of the OCN, including the underlying FlowGrid_C.</span>
<span class="sd">        Also copies the current RNG state. The new copy and the original</span>
<span class="sd">        will be independent from each other and behave identically statistically.</span>

<span class="sd">        If you want the copy to have a different random state, call :meth:`reseed`</span>
<span class="sd">        after copying.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cpy</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">cpy</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span>
        <span class="n">cpy</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span>
        
        <span class="n">cpy</span><span class="o">.</span><span class="n">__history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">cpy_p_c_graph</span> <span class="o">=</span> <span class="n">_bindings</span><span class="o">.</span><span class="n">libocn</span><span class="o">.</span><span class="n">fg_copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__p_c_graph</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cpy_p_c_graph</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">MemoryError</span><span class="p">(</span><span class="s2">&quot;Failed to copy FlowGrid_C in OCN.__copy__&quot;</span><span class="p">)</span>
        <span class="n">cpy</span><span class="o">.</span><span class="n">__p_c_graph</span> <span class="o">=</span> <span class="n">cpy_p_c_graph</span>
        <span class="k">return</span> <span class="n">cpy</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;OCN&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a deep copy of the OCN, including the underlying FlowGrid_C.</span>
<span class="sd">        Also copies the current RNG state. The new copy and the original</span>
<span class="sd">        will be independent from each other and behave identically statistically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__copy__</span><span class="p">()</span>
    
<div class="viewcode-block" id="OCN.copy">
<a class="viewcode-back" href="../../index.html#PyOCN.OCN.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;OCN&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a deep copy of the OCN, including the underlying FlowGrid_C.</span>
<span class="sd">        Also copies the current RNG state. The new copy and the original</span>
<span class="sd">        will be independent from each other and behave identically statistically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__copy__</span><span class="p">()</span></div>


<div class="viewcode-block" id="OCN.compute_energy">
<a class="viewcode-back" href="../../index.html#PyOCN.OCN.compute_energy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the current energy of the network.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The computed energy value.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This constructs a temporary ``DiGraph`` view to aggregate node</span>
<span class="sd">        energies from drained areas using the exponent ``gamma``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_bindings</span><span class="o">.</span><span class="n">libocn</span><span class="o">.</span><span class="n">ocn_compute_energy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__p_c_graph</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">)</span></div>

    
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Energy of the current OCN.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Current energy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__p_c_graph</span><span class="o">.</span><span class="n">contents</span><span class="o">.</span><span class="n">energy</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resolution of the current OCN grid in m (read-only).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Current resolution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__p_c_graph</span><span class="o">.</span><span class="n">contents</span><span class="o">.</span><span class="n">resolution</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nroots</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of root nodes in the current OCN grid (read-only).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Current number of root nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__p_c_graph</span><span class="o">.</span><span class="n">contents</span><span class="o">.</span><span class="n">nroots</span><span class="p">)</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dims</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Grid dimensions of the FlowGrid (read-only).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple[int, int]</span>
<span class="sd">            ``(rows, cols)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__p_c_graph</span><span class="o">.</span><span class="n">contents</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">row</span><span class="p">),</span>
            <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__p_c_graph</span><span class="o">.</span><span class="n">contents</span><span class="o">.</span><span class="n">dims</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether the grid allows wrapping around the edges (toroidal).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Current wrap setting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__p_c_graph</span><span class="o">.</span><span class="n">contents</span><span class="o">.</span><span class="n">wrap</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">rng</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple[int, int, int, int]</span>
<span class="sd">            the current random state of the internal RNG as four 32-bit unsigned integers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">s</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__p_c_graph</span><span class="o">.</span><span class="n">contents</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>
    
    <span class="nd">@rng</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">rng</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">Generator</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Seed the internal RNG.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        random_state : int | numpy.random.Generator | None, optional</span>
<span class="sd">            Seed or generator for RNG. If None, system entropy is used.</span>
<span class="sd">            If an integer or Generator is provided, the</span>
<span class="sd">            new seed is drawn from it directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">Generator</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;RNG must be initialized with an integer/Generator/None.&quot;</span><span class="p">)</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">32</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">_bindings</span><span class="o">.</span><span class="n">rng_state_t</span><span class="p">()</span>
        <span class="n">_bindings</span><span class="o">.</span><span class="n">libocn</span><span class="o">.</span><span class="n">rng_seed</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">rng</span><span class="p">),</span> <span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__p_c_graph</span><span class="o">.</span><span class="n">contents</span><span class="o">.</span><span class="n">rng</span> <span class="o">=</span> <span class="n">rng</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">history</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        numpy array of shape (n_iterations, 3) recording the iteration index, energy, and temperature at each iteration during optimization.</span>
<span class="sd">        If multiple fit calls are made, history is appended to this array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            The optimization history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span>

<div class="viewcode-block" id="OCN.to_digraph">
<a class="viewcode-back" href="../../index.html#PyOCN.OCN.to_digraph">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_digraph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a NetworkX ``DiGraph`` view of the current grid.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nx.DiGraph</span>
<span class="sd">            A DAG with the following node attributes per node:</span>

<span class="sd">            - ``pos``: ``(row, col)`` grid position</span>
<span class="sd">            - ``drained_area``: drained area value</span>
<span class="sd">            - ``energy``: cumulative energy at the node</span>
<span class="sd">            - ``watershed_id``: integer watershed ID (roots have watershed id = -1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="n">fgconv</span><span class="o">.</span><span class="n">to_digraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__p_c_graph</span><span class="o">.</span><span class="n">contents</span><span class="p">)</span>
        <span class="n">assign_subwatersheds</span><span class="p">(</span><span class="n">dag</span><span class="p">)</span>

        <span class="n">node_energies</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">(</span><span class="n">dag</span><span class="p">):</span>
            <span class="n">node_energies</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;drained_area&#39;</span><span class="p">]</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> 
                <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">node_energies</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">dag</span><span class="p">,</span> <span class="n">node_energies</span><span class="p">,</span> <span class="s1">&#39;energy&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dag</span></div>

    
<div class="viewcode-block" id="OCN.to_gtiff">
<a class="viewcode-back" href="../../index.html#PyOCN.OCN.to_gtiff">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_gtiff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">west</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span> <span class="n">north</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span> <span class="n">crs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span><span class="nb">str</span><span class="o">|</span><span class="n">PathLike</span><span class="p">,</span> <span class="n">unwrap</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export a raster of the current FlowGrid to a GeoTIFF file</span>
<span class="sd">        using rasterio. The resulting raster has 3 bands: `energy`, `drained_area`, and `watershed_id`.</span>
<span class="sd">        The `watershed_id` band contains integer watershed IDs assigned to each node,</span>
<span class="sd">        with root nodes assigned a value of -1. NA values are either np.nan (for energy and drained_area)</span>
<span class="sd">        or -9999 (for watershed_id).</span>

<span class="sd">        N.B. This uses the :attr:`resolution` attribute to set pixel size in the raster.</span>
<span class="sd">        This function does not check for unit compatibility, so it is up to the user</span>
<span class="sd">        to ensure the resolution and CRS units match. By default,</span>
<span class="sd">        the resolution is set to 1.0. Using a CRS with degree units in this case</span>
<span class="sd">        would result in a pixel size of 1 degree, which is likely not what you want.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        west : float</span>
<span class="sd">            The western border of the raster in crs units, corresponding</span>
<span class="sd">            to column 0.</span>
<span class="sd">        north : float</span>
<span class="sd">            The northern border of the raster in crs units, corresponding</span>
<span class="sd">            to row 0.</span>
<span class="sd">        crs : Any</span>
<span class="sd">            The crs for the resulting gtiff, passed to `rasterio.open`</span>
<span class="sd">        path : str or Pathlike</span>
<span class="sd">            The output path for the resulting gtiff file.</span>
<span class="sd">        unwrap : bool, default True</span>
<span class="sd">            If True and the current OCN has periodic boundaries, the</span>
<span class="sd">            resulting raster will be transformed so connected grid cells </span>
<span class="sd">            are adjacent in the raster. This will result in a larger raster</span>
<span class="sd">            with some nan values. If False or the current OCN does not have</span>
<span class="sd">            periodic boundaries, then no transformation is applied and the</span>
<span class="sd">            raster will have the same dimensions as the current OCN grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">rasterio</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">rasterio.transform</span><span class="w"> </span><span class="kn">import</span> <span class="n">from_origin</span>
        <span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                <span class="s2">&quot;PyOCN.OCN.to_gtiff() requires rasterio to be installed. Install with `pip install rasterio`.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">unwrap</span><span class="o">=</span><span class="n">unwrap</span><span class="p">)</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">energy</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">drained_area</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">watershed_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="o">-</span><span class="mi">9999</span><span class="p">,</span> <span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
            <span class="n">watershed_id</span> <span class="o">=</span> <span class="n">watershed_id</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">transform</span> <span class="o">=</span> <span class="n">from_origin</span><span class="p">(</span><span class="n">west</span><span class="p">,</span> <span class="n">north</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">)</span>

        <span class="c1"># Write three bands: 1=energy, 2=drained_area, 3=watershed_id</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span>
            <span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">),</span>
            <span class="s2">&quot;w&quot;</span><span class="p">,</span>
            <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;GTiff&quot;</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">width</span><span class="o">=</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">count</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
            <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="n">compress</span><span class="o">=</span><span class="s2">&quot;deflate&quot;</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
            <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">drained_area</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">watershed_id</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="c1"># Band descriptions (nice to have)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dst</span><span class="o">.</span><span class="n">set_band_description</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;energy&quot;</span><span class="p">)</span>
                <span class="n">dst</span><span class="o">.</span><span class="n">set_band_description</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;drained_area&quot;</span><span class="p">)</span>
                <span class="n">dst</span><span class="o">.</span><span class="n">set_band_description</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;watershed_id&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span></div>

    
<div class="viewcode-block" id="OCN.to_numpy">
<a class="viewcode-back" href="../../index.html#PyOCN.OCN.to_numpy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unwrap</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export the current FlowGrid to a numpy array with shape (2, rows, cols).</span>
<span class="sd">        Has two channels: 0=energy, 1=drained_area.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unwrap : bool, default True</span>
<span class="sd">            If True and the current OCN has periodic boundaries, the</span>
<span class="sd">            resulting array will be transformed so connected grid cells </span>
<span class="sd">            are adjacent in the array. This will result in a larger array</span>
<span class="sd">            with some nan values. If False or the current OCN does not have</span>
<span class="sd">            periodic boundaries, then no transformation is applied and the</span>
<span class="sd">            resulting array will have the same dimensions as the current OCN grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_digraph</span><span class="p">()</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span> <span class="ow">and</span> <span class="n">unwrap</span><span class="p">:</span>
            <span class="n">dag</span> <span class="o">=</span> <span class="n">unwrap_digraph</span><span class="p">(</span><span class="n">dag</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">dag</span><span class="p">,</span> <span class="s1">&#39;pos&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="n">max_r</span><span class="p">,</span> <span class="n">max_c</span> <span class="o">=</span> <span class="n">positions</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">drained_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">watershed_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;pos&#39;</span><span class="p">]</span>
            <span class="n">energy</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;energy&#39;</span><span class="p">]</span>
            <span class="n">drained_area</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;drained_area&#39;</span><span class="p">]</span>
            <span class="n">watershed_id</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;watershed_id&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">energy</span><span class="p">,</span> <span class="n">drained_area</span><span class="p">,</span> <span class="n">watershed_id</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="OCN.to_xarray">
<a class="viewcode-back" href="../../index.html#PyOCN.OCN.to_xarray">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_xarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unwrap</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;xr.Dataset&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export the current FlowGrid to an xarray Dataset</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unwrap : bool, default True</span>
<span class="sd">            If True and the current OCN has periodic boundaries, the</span>
<span class="sd">            resulting rasters will be transformed so connected grid cells</span>
<span class="sd">            are adjacent in the output. This will result in a larger raster</span>
<span class="sd">            with some nan values. If False or the current OCN does not have</span>
<span class="sd">            periodic boundaries, then no transformation is applied and the</span>
<span class="sd">            resulting raster will have the same dimensions as the current OCN grid.</span>
<span class="sd">            </span>
<span class="sd">            When unwrapping, the (0,0) coordinate</span>
<span class="sd">            will be set to the position of the &quot;main&quot; root node, defined as</span>
<span class="sd">            the root node with the smallest row*cols + col value. Otherwise,</span>
<span class="sd">            (0,0) will be the top-left corner of the grid.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xr.Dataset</span>
<span class="sd">         an xarray Dataset with data variables:</span>
<span class="sd">            - `energy_rasters` (np.float64) representing energy at each grid cell</span>
<span class="sd">            - `area_rasters` (np.float64) representing drained area at each grid cell</span>
<span class="sd">            - `watershed_id` (np.int32). NA value is -9999. Roots have value -1. Represents the watershed membership ID for each grid cell.</span>
<span class="sd">        and coordinates:</span>
<span class="sd">            - `y` (float) representing the northing coordinate of each row.</span>
<span class="sd">            - `x` (float) representing the easting coordinate of each column.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
        <span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                <span class="s2">&quot;PyOCN.OCN.to_xarray() requires xarray to be installed. Install with `pip install xarray`.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        
        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span>

        <span class="n">dag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_digraph</span><span class="p">()</span>
        <span class="n">row_root</span><span class="p">,</span> <span class="n">col_root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span> <span class="ow">and</span> <span class="n">unwrap</span><span class="p">:</span>
            <span class="n">roots</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">out_degree</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">main_root</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;pos&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;pos&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            
            <span class="n">dag</span> <span class="o">=</span> <span class="n">unwrap_digraph</span><span class="p">(</span><span class="n">dag</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">dag</span><span class="p">,</span> <span class="s1">&#39;pos&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="n">max_r</span><span class="p">,</span> <span class="n">max_c</span> <span class="o">=</span> <span class="n">positions</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># compute the new position of the root node after unwrapping. This will be the new origin (0,0).</span>
            <span class="n">row_root</span><span class="p">,</span> <span class="n">col_root</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">main_root</span><span class="p">][</span><span class="s1">&#39;pos&#39;</span><span class="p">]</span>

        <span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">drained_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">watershed_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;pos&#39;</span><span class="p">]</span>
            <span class="n">energy</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;energy&#39;</span><span class="p">]</span>
            <span class="n">drained_area</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;drained_area&#39;</span><span class="p">]</span>
            <span class="n">watershed_id</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;watershed_id&#39;</span><span class="p">]</span>
        <span class="n">array_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">energy</span><span class="p">,</span> <span class="n">drained_area</span><span class="p">,</span> <span class="n">watershed_id</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">dims</span> <span class="o">=</span> <span class="n">array_out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># replace nan with -9999 for watershed_id since integers can&#39;t be nan</span>
        <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">array_out</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nan</span><span class="o">=-</span><span class="mi">9999</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
            <span class="n">watershed_id</span> <span class="o">=</span> <span class="n">array_out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span>
            <span class="n">data_vars</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;energy_rasters&quot;</span><span class="p">:</span> <span class="p">([</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">array_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)),</span>
                <span class="s2">&quot;area_rasters&quot;</span><span class="p">:</span> <span class="p">([</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">array_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)),</span>
                <span class="s2">&quot;watershed_id&quot;</span><span class="p">:</span> <span class="p">([</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">watershed_id</span><span class="p">),</span>
            <span class="p">},</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">row_root</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">row_root</span> <span class="o">+</span> <span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">),</span>
                <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">col_root</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">col_root</span> <span class="o">+</span> <span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">),</span>
            <span class="p">},</span>
            <span class="n">attrs</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;OCN fit result arrays&quot;</span><span class="p">,</span>
                <span class="s2">&quot;resolution&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span>
                <span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span>
                <span class="s2">&quot;master_seed&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">),</span>
                <span class="s2">&quot;wrap&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="OCN.single_iteration">
<a class="viewcode-back" href="../../index.html#PyOCN.OCN.single_iteration">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">single_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span> <span class="n">array_report</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unwrap</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;xr.Dataset | None&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Perform a single iteration of the optimization algorithm at a given temperature. Updates the internal history attribute.</span>
<span class="sd">        See :meth:`fit` for details on the algorithm.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        temperature : float</span>
<span class="sd">            Temperature parameter governing acceptance probability. Typical</span>
<span class="sd">            range is a fraction of ocn.energy.</span>
<span class="sd">        array_report : bool, default False</span>
<span class="sd">            If True (default), the returned result will be an xarray.Dataset.</span>
<span class="sd">            See :meth:`fit` for details. The returned object will have an iteration dimension of size 1.</span>
<span class="sd">            Requires xarray to be installed.</span>
<span class="sd">        unwrap : bool, default True</span>
<span class="sd">            If True and the current OCN has periodic boundaries, the</span>
<span class="sd">            resulting rasters will be transformed so connected grid cells</span>
<span class="sd">            are adjacent in the output. This will result in a larger raster</span>
<span class="sd">            with some nan values. If False or the current OCN does not have</span>
<span class="sd">            periodic boundaries, then no transformation is applied and the</span>
<span class="sd">            resulting raster will have the same dimensions as the current OCN grid.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        LibOCNError</span>
<span class="sd">            If the underlying C routine reports an error status.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># FlowGrid *G, uint32_t *total_tries, double gamma, double temperature</span>
        <span class="n">check_status</span><span class="p">(</span><span class="n">_bindings</span><span class="o">.</span><span class="n">libocn</span><span class="o">.</span><span class="n">ocn_single_erosion_event</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__p_c_graph</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> 
            <span class="n">temperature</span><span class="p">,</span>
        <span class="p">))</span>

        <span class="c1"># append to history</span>
        <span class="n">last_iteration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__history</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">history</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">last_iteration</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="n">temperature</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">__history</span><span class="p">,</span> <span class="n">history</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">array_report</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">(</span><span class="n">unwrap</span><span class="o">=</span><span class="n">unwrap</span><span class="p">)</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s2">&quot;iteration&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]})</span>

        <span class="k">return</span> <span class="n">ds</span></div>

    
<div class="viewcode-block" id="OCN.fit">
<a class="viewcode-back" href="../../index.html#PyOCN.OCN.fit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cooling_rate</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">constant_phase</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">n_iterations</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pbar</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">array_reports</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_iterations_per_loop</span><span class="o">=</span><span class="mi">10_000</span><span class="p">,</span>
        <span class="n">unwrap</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;xr.Dataset | None&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience function to optimize the OCN using the simulated annealing algorithm from Carraro et al (2020).</span>
<span class="sd">        For finer control over the optimization process, use :meth:`fit_custom_cooling` or use :meth:`single_erosion_event` in a loop.</span>

<span class="sd">        This performs ``n_iterations`` erosion events, accepting or rejecting</span>
<span class="sd">        proposals according to a temperature schedule defined by the annealing algorithm. </span>
<span class="sd">        A proposal consists of changing the outflow direction of a randomly selected vertex. </span>
<span class="sd">        The new outflow direction is chosen uniformly from the valid neighbors.</span>
<span class="sd">        A proposal is valid if it maintains a well-formed graph structure.</span>

<span class="sd">        The :attr:`history` attribute is updated in-place after optimization finishes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ocn : OCN</span>
<span class="sd">            The OCN instance to optimize.</span>
<span class="sd">        cooling_rate : float, default 1.0</span>
<span class="sd">            Cooling rate parameter in the annealing algorithm. Typical range is 0.5-1.5.</span>
<span class="sd">            Higher values result in faster cooling and a greedier search.</span>
<span class="sd">            Lower values result in slower cooling and more thorough exploration of the solution space, but slower convergence and lower stability.</span>
<span class="sd">        constant_phase : float, default 0.0</span>
<span class="sd">            Amount of time to hold temeprature constant at the start of the optimization.</span>
<span class="sd">            This is a fraction of n_iterations, and must be in the range [0, 1].</span>
<span class="sd">            A value of 0.0 (default) means the temperature starts cooling immediately</span>
<span class="sd">            from the initial temperature. A value of 1.0 means the temperature is held</span>
<span class="sd">            constant for the entire optimization.</span>
<span class="sd">        n_iterations : int, optional</span>
<span class="sd">            Total number of iterations. Defaults to ``40 * rows * cols``.</span>
<span class="sd">            Always at least ``energy_reports * 10`` (this should only matter for</span>
<span class="sd">            extremely small grids, where ``rows * cols &lt; 256``).</span>
<span class="sd">        pbar : bool, default True</span>
<span class="sd">            Whether to display a progress bar.</span>
<span class="sd">        array_reports : int, default 0</span>
<span class="sd">            Number of timepoints (approximately) at which to save the state of the FlowGrid.</span>
<span class="sd">            If 0 (default), returns None. If &gt;0, returns an xarray.Dataset</span>
<span class="sd">            containing the state of the FlowGrid at approximately evenly spaced intervals</span>
<span class="sd">            throughout the optimization, including the initial and final states. Requires xarray to be installed.</span>
<span class="sd">            </span>
<span class="sd">            The returned xarray.Dataset will have coordinates:</span>
<span class="sd">                - `y` (float) representing the northing coordinate of each row</span>
<span class="sd">                - `x` (float) representing the easting coordinate of each column</span>
<span class="sd">                - `iteration` (int) representing the iteration index at which the data was recorded</span>
<span class="sd">            data variables:</span>
<span class="sd">                - `energy_rasters` (np.float64) representing energy at each grid cell</span>
<span class="sd">                - `area_rasters` (np.float64) representing drained area at each grid cell</span>
<span class="sd">                - `watershed_id` (np.int32). NA value is -9999. Roots have value -1. Represents the watershed membership ID for each grid cell.</span>
<span class="sd">            The coordiante (0, 0) is the top-left corner of the grid.</span>

<span class="sd">            If the OCN has a periodic boundary condition, the following changes apply: </span>
<span class="sd">                - The (0,0) coordinate will be set to the position of the &quot;main&quot; root node, defined as</span>
<span class="sd">                the root node with the smallest row*cols + col value</span>
<span class="sd">                - The rasters will be unwrapped to a non-periodic representation, which may result in larger rasters.</span>
<span class="sd">                - The size of the final rasters are the maximum extent of the unwrapped grid, taken across all iterations.</span>

<span class="sd">            Generating reports requires additional memory and computation time.</span>
<span class="sd">            </span>
<span class="sd">        tol : float, optional</span>
<span class="sd">            If provided, optimization will stop early if the relative change</span>
<span class="sd">            in energy between reports is less than `tol`. Must be positive.</span>
<span class="sd">            If None (default), no early stopping is performed.</span>
<span class="sd">            Recommended values are in the range 1e-4 to 1e-6.</span>
<span class="sd">        max_iterations_per_loop: int, optional</span>
<span class="sd">            If provided, the number of iterations steps to perform in each &quot;chunk&quot;</span>
<span class="sd">            of optimization. Energy and output arrays can be reported no more often</span>
<span class="sd">            than this. Recommended values are 1_000-1_000_000. Default is 10_000.</span>
<span class="sd">        unwrap: bool, default True</span>
<span class="sd">            If True and the current OCN has periodic boundaries, the</span>
<span class="sd">            resulting rasters will be transformed so connected grid cells</span>
<span class="sd">            are adjacent in the output. This will result in a larger raster</span>
<span class="sd">            with some nan values. If False or the current OCN does not have</span>
<span class="sd">            periodic boundaries, then no transformation is applied and the</span>
<span class="sd">            resulting raster will have the same dimensions as the current OCN grid.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xr.Dataset | None</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>

<span class="sd">        Warns</span>
<span class="sd">        -----</span>
<span class="sd">        UserWarning</span>

<span class="sd">        Optimization Algorithm</span>
<span class="sd">        ----------------------</span>
<span class="sd">        At iteration ``i``, the outflow of a random grid cell if proposed to be rerouted.</span>
<span class="sd">        The proposal is accepted with the probability</span>
<span class="sd">        .. math::</span>

<span class="sd">            P(\text{accept}) = e^{-\Delta E / T},</span>

<span class="sd">        where :math:`\Delta E` is the change in energy the change would cause </span>
<span class="sd">        and :math:`T` is the temperature of the network.</span>

<span class="sd">        The total energy of the system is computed from the drained areas of each grid cell :math:`k` as</span>

<span class="sd">        .. math::</span>
<span class="sd">            E = \sum_k A_k^\gamma</span>

<span class="sd">        The temperature of the network is governed by a cooling schedule, which is a function of iteration index.</span>
<span class="sd">        </span>
<span class="sd">        Note that when :math:`\Delta E &lt; 0`, the move is always accepted.</span>

<span class="sd">        Simulated Annealing Schedule</span>
<span class="sd">        ----------------------------</span>
<span class="sd">        The cooling schedule used by this method is a piecewise function of iteration index:</span>
<span class="sd">        .. math::</span>

<span class="sd">            T(i) = \begin{cases}</span>
<span class="sd">                E_0 &amp; i &lt; C N \\</span>
<span class="sd">                E_0 \cdot e^{\;i - C N} &amp; i \ge C N</span>
<span class="sd">            \end{cases}</span>

<span class="sd">        where :math:`E_0` is the initial energy, :math:`N` is the total number</span>
<span class="sd">        of iterations, and :math:`C` is ``constant_phase``. Decreasing-energy</span>
<span class="sd">        moves (:math:`\Delta E &lt; 0`) are always accepted.</span>

<span class="sd">        Alternative cooling schedules can be implemented using :meth:`fit_custom_cooling`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># make sure energy is up to date, useful if the user modified any parameters manually</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__p_c_graph</span><span class="o">.</span><span class="n">contents</span><span class="o">.</span><span class="n">energy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_energy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">constant_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">constant_phase</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="n">cooling_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cooling_rate</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="n">n_iterations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_iterations</span> <span class="o">=</span> <span class="mi">40</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># create a cooling schedule from arguments</span>
        <span class="n">cooling_func</span> <span class="o">=</span> <span class="n">simulated_annealing_schedule</span><span class="p">(</span>
            <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">E0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span>
            <span class="n">constant_phase</span><span class="o">=</span><span class="n">constant_phase</span><span class="p">,</span>
            <span class="n">n_iterations</span><span class="o">=</span><span class="n">n_iterations</span><span class="p">,</span>
            <span class="n">cooling_rate</span><span class="o">=</span><span class="n">cooling_rate</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_custom_cooling</span><span class="p">(</span>
            <span class="n">cooling_func</span><span class="o">=</span><span class="n">cooling_func</span><span class="p">,</span>
            <span class="n">n_iterations</span><span class="o">=</span><span class="n">n_iterations</span><span class="p">,</span>
            <span class="n">pbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">,</span>
            <span class="n">array_reports</span><span class="o">=</span><span class="n">array_reports</span><span class="p">,</span>
            <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span>
            <span class="n">max_iterations_per_loop</span><span class="o">=</span><span class="n">max_iterations_per_loop</span><span class="p">,</span>
            <span class="n">unwrap</span><span class="o">=</span><span class="n">unwrap</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="OCN.fit_custom_cooling">
<a class="viewcode-back" href="../../index.html#PyOCN.OCN.fit_custom_cooling">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit_custom_cooling</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cooling_func</span><span class="p">:</span><span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">n_iterations</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">iteration_start</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">pbar</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">array_reports</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_iterations_per_loop</span><span class="o">=</span><span class="mi">10_000</span><span class="p">,</span>
        <span class="n">unwrap</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;xr.Dataset | None&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimize the OCN using the a custom cooling schedule. This allows for</span>
<span class="sd">        multi-stage optimizations or other custom cooling schedules not covered by the default simulated annealing schedule</span>
<span class="sd">        from Carraro et al (2020).</span>

<span class="sd">        See :meth:`fit` for additional details on the optimization algorithm and parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ocn : OCN</span>
<span class="sd">            The OCN instance to optimize.</span>
<span class="sd">        cooling_func : Callable[[np.ndarray], np.ndarray]</span>
<span class="sd">            A function that takes an array of iteration indices and returns an array of temperatures.</span>
<span class="sd">            This function defines the cooling schedule for the optimization. Note that the function</span>
<span class="sd">            should return temperatures that are appropriate for the current energy of the OCN.</span>
<span class="sd">        n_iterations : int, optional</span>
<span class="sd">        iteration_start : int, default 0</span>
<span class="sd">            The starting iteration index. This is useful for continuing an optimization</span>
<span class="sd">            from a previous run. Must be a non-negative integer. If provided, ``n_iterations``</span>
<span class="sd">            is the number of additional iterations to perform. The iteration number passed to</span>
<span class="sd">            ``cooling_func`` will be ``iteration_start + i`` where ``i`` is the current iteration index</span>
<span class="sd">            in the range ``[0, n_iterations-1]``.</span>
<span class="sd">        pbar : bool, default True</span>
<span class="sd">        array_reports : int, default 0</span>
<span class="sd">        tol : float, optional</span>
<span class="sd">        max_iterations_per_loop: int, optional</span>
<span class="sd">        unwrap: bool, default True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xr.Dataset | None</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>

<span class="sd">        Warns</span>
<span class="sd">        -----</span>
<span class="sd">        UserWarning</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># validate inputs</span>
        <span class="k">if</span> <span class="n">n_iterations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_iterations</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">40</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">n_iterations</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n_iterations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_iterations must be a positive integer, got </span><span class="si">{</span><span class="n">n_iterations</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">array_reports</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">array_reports</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;array_reports must be a non-negative integer, got </span><span class="si">{</span><span class="n">array_reports</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iteration_start</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)))</span> <span class="ow">or</span> <span class="n">iteration_start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;iteration_start must be a non-negative integer, got </span><span class="si">{</span><span class="n">iteration_start</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tol</span><span class="p">,</span> <span class="n">Number</span><span class="p">))</span> <span class="ow">or</span> <span class="n">tol</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tol must be a positive number or None, got </span><span class="si">{</span><span class="n">tol</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">memory_est</span> <span class="o">=</span> <span class="n">array_reports</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">8</span> 
        <span class="k">if</span> <span class="n">memory_est</span> <span class="o">&gt;</span> <span class="mf">20e6</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Requesting </span><span class="si">{</span><span class="n">array_reports</span><span class="si">}</span><span class="s2"> array is estimated to use </span><span class="si">{</span><span class="n">memory_est</span><span class="o">/</span><span class="mf">1e6</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">MB of memory. Consider reducing array_reports or increasing max_iterations_per_loop if memory is a concern.&quot;</span><span class="p">)</span>
        
        <span class="n">xarray_out</span> <span class="o">=</span> <span class="n">array_reports</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">xarray_out</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
            <span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                    <span class="s2">&quot;PyOCN.OCN.fit() with array_report&gt;0 requires xarray to be installed. Install with `pip install xarray`.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="c1"># preallocate output arrays</span>
        <span class="n">max_iterations_per_loop</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_iterations_per_loop</span><span class="p">)</span>
        <span class="n">max_iterations_per_loop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_iterations_per_loop</span><span class="p">)</span>
        <span class="n">n_iterations</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_iterations</span><span class="p">)</span>
        <span class="n">n_iterations</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_iterations</span><span class="p">)</span>
        <span class="n">max_iterations_per_loop</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_iterations</span><span class="p">,</span> <span class="n">max_iterations_per_loop</span><span class="p">)</span>

        <span class="c1"># preallocate output arrays</span>
        <span class="n">energy_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">n_iterations</span><span class="o">//</span><span class="n">max_iterations_per_loop</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="c1"># always report energy when reporting arrays</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">array_reports</span><span class="p">:</span>
            <span class="n">array_report_interval</span> <span class="o">=</span> <span class="n">n_iterations</span> <span class="o">//</span> <span class="n">array_reports</span>
            <span class="n">array_report_interval</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">array_report_interval</span><span class="p">,</span> <span class="n">max_iterations_per_loop</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">array_report_interval</span> <span class="o">=</span> <span class="n">n_iterations</span><span class="o">*</span><span class="mi">2</span>  <span class="c1"># never report arrays</span>

        <span class="c1"># temporary buffer to use for passing temperatures to libocn</span>
        <span class="n">anneal_buf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">max_iterations_per_loop</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">anneal_ptr</span> <span class="o">=</span> <span class="n">anneal_buf</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">))</span>

        <span class="n">completed_iterations</span> <span class="o">=</span> <span class="n">iteration_start</span>
        <span class="n">n_iterations</span> <span class="o">+=</span> <span class="n">iteration_start</span>

        <span class="c1"># set up reporting</span>
        <span class="n">array_report_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">energy_report_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ds_out_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">array_report_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">completed_iterations</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xarray_out</span><span class="p">:</span>
            <span class="n">ds_out_dict</span><span class="p">[</span><span class="n">completed_iterations</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">(</span><span class="n">unwrap</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">)</span>
        <span class="n">energy_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy</span>
        <span class="n">energy_report_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">completed_iterations</span><span class="p">)</span>

        <span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span>
            <span class="n">total</span><span class="o">=</span><span class="n">n_iterations</span> <span class="o">-</span> <span class="n">iteration_start</span><span class="p">,</span> 
            <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;OCN Fit&quot;</span><span class="p">,</span> 
            <span class="n">unit_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">dynamic_ncols</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
            <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="p">(</span><span class="n">pbar</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        
        <span class="k">while</span> <span class="n">completed_iterations</span> <span class="o">&lt;</span> <span class="n">n_iterations</span><span class="p">:</span>
            <span class="n">iterations_this_loop</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_iterations_per_loop</span><span class="p">,</span> <span class="n">n_iterations</span> <span class="o">-</span> <span class="n">completed_iterations</span><span class="p">)</span>
            <span class="n">anneal_buf</span><span class="p">[:</span><span class="n">iterations_this_loop</span><span class="p">]</span> <span class="o">=</span> <span class="n">cooling_func</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">completed_iterations</span><span class="p">,</span> <span class="n">completed_iterations</span> <span class="o">+</span> <span class="n">iterations_this_loop</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># main call to optimizer in libocn</span>
            <span class="n">e_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy</span>
            <span class="n">check_status</span><span class="p">(</span><span class="n">_bindings</span><span class="o">.</span><span class="n">libocn</span><span class="o">.</span><span class="n">ocn_outer_ocn_loop</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__p_c_graph</span><span class="p">,</span> 
                <span class="n">iterations_this_loop</span><span class="p">,</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> 
                <span class="n">anneal_ptr</span><span class="p">,</span>
            <span class="p">))</span>
            <span class="n">e_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy</span>
            <span class="n">completed_iterations</span> <span class="o">+=</span> <span class="n">iterations_this_loop</span>
            
            <span class="c1"># always report energy</span>
            <span class="n">energy_out</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">energy_report_idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">e_new</span>
            <span class="n">energy_report_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">completed_iterations</span><span class="p">)</span>
            <span class="c1"># report arrays if requested</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">xarray_out</span> 
                <span class="ow">and</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">completed_iterations</span> <span class="o">%</span> <span class="n">array_report_interval</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_iterations_per_loop</span>  <span class="c1"># intermediate report</span>
                    <span class="ow">or</span> <span class="n">completed_iterations</span> <span class="o">&gt;=</span> <span class="n">n_iterations</span>  <span class="c1"># final report</span>
                <span class="p">)</span>
            <span class="p">):</span>
                <span class="n">array_report_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">completed_iterations</span><span class="p">)</span>
                <span class="n">ds_out_dict</span><span class="p">[</span><span class="n">completed_iterations</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">(</span><span class="n">unwrap</span><span class="o">=</span><span class="n">unwrap</span><span class="p">)</span>  <span class="c1"># TODO: pre-allocate this dict?</span>


            <span class="c1"># progress bar update</span>
            <span class="c1"># TODO: move this to a separate function</span>
            <span class="k">if</span> <span class="n">pbar</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbosity</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">RED</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[31m&#39;</span>
                <span class="n">YELLOW</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[33m&#39;</span>
                <span class="n">CYAN</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[36m&#39;</span>
                <span class="n">END</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\033</span><span class="s1">[0m&#39;</span>
                <span class="n">T_over_E</span> <span class="o">=</span> <span class="n">anneal_buf</span><span class="p">[</span><span class="n">iterations_this_loop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">e_old</span><span class="o">*</span><span class="mi">100</span>
                <span class="n">ToE_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">T_over_E</span><span class="p">))</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="nb">int</span><span class="p">((</span><span class="n">T_over_E</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">T_over_E</span><span class="p">))</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">%&quot;</span>
                <span class="n">de_over_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">e_new</span> <span class="o">-</span> <span class="n">e_old</span><span class="p">)</span><span class="o">/</span><span class="n">e_old</span><span class="o">*</span><span class="mi">100</span>

                <span class="n">dEoE_sign</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span> <span class="k">if</span> <span class="n">de_over_E</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;-&#39;</span>
                <span class="n">dEoE_integer_part</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">de_over_E</span><span class="p">)))</span>
                <span class="n">dEoE_fractional_part</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">de_over_E</span><span class="p">)</span> <span class="o">-</span> <span class="n">dEoE_integer_part</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
                <span class="n">dEoE_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dEoE_sign</span><span class="si">}{</span><span class="n">dEoE_integer_part</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">dEoE_fractional_part</span><span class="si">:</span><span class="s2">02d</span><span class="si">}</span><span class="s2">%&quot;</span>
                <span class="k">if</span> <span class="n">T_over_E</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">:</span> <span class="n">ToE_str</span> <span class="o">=</span> <span class="n">RED</span> <span class="o">+</span> <span class="n">ToE_str</span> <span class="o">+</span> <span class="n">END</span>
                <span class="k">elif</span> <span class="n">T_over_E</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span> <span class="n">ToE_str</span> <span class="o">=</span> <span class="n">YELLOW</span> <span class="o">+</span> <span class="n">ToE_str</span> <span class="o">+</span> <span class="n">END</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">ToE_str</span> <span class="o">=</span> <span class="n">CYAN</span> <span class="o">+</span> <span class="n">ToE_str</span> <span class="o">+</span> <span class="n">END</span>
                <span class="k">if</span> <span class="n">de_over_E</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="n">dEoE_str</span> <span class="o">=</span> <span class="n">RED</span> <span class="o">+</span> <span class="n">dEoE_str</span> <span class="o">+</span> <span class="n">END</span>
                <span class="k">elif</span> <span class="n">de_over_E</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">dEoE_str</span> <span class="o">=</span> <span class="n">YELLOW</span> <span class="o">+</span> <span class="n">dEoE_str</span> <span class="o">+</span> <span class="n">END</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">dEoE_str</span> <span class="o">=</span> <span class="n">CYAN</span> <span class="o">+</span> <span class="n">dEoE_str</span> <span class="o">+</span> <span class="n">END</span>

                <span class="n">pbar</span><span class="o">.</span><span class="n">set_postfix</span><span class="p">({</span>
                    <span class="s2">&quot;E&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">energy</span><span class="si">:</span><span class="s2">.1e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> 
                    <span class="s2">&quot;T/E&quot;</span><span class="p">:</span> <span class="n">ToE_str</span><span class="p">,</span>
                    <span class="s2">&quot;ΔE/E&quot;</span><span class="p">:</span> <span class="n">dEoE_str</span><span class="p">,</span>
                <span class="p">})</span>
                <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">iterations_this_loop</span><span class="p">)</span>

            <span class="c1"># check for convergence if requested</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">tol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> 
                <span class="ow">and</span> <span class="p">(</span><span class="n">e_new</span> <span class="o">&lt;=</span> <span class="n">e_old</span><span class="p">)</span> 
                <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">((</span><span class="n">e_old</span> <span class="o">-</span> <span class="n">e_new</span><span class="p">)</span><span class="o">/</span><span class="n">e_old</span><span class="p">)</span> <span class="k">if</span> <span class="n">e_old</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Convergence reached, stopping optimization.&quot;</span><span class="p">)</span>
                <span class="c1"># if self.verbosity &gt;= 0:</span>
                <span class="k">break</span>
        
        <span class="n">pbar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="c1"># update energy and temperature history</span>
        <span class="n">last_history_iteration</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">skip_first</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">history</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span>
            <span class="n">last_history_iteration</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">energy_report_idx</span><span class="p">)[</span><span class="n">skip_first</span><span class="p">:]</span> <span class="o">-</span> <span class="n">iteration_start</span><span class="p">,</span>
            <span class="n">energy_out</span><span class="p">[</span><span class="n">skip_first</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">energy_report_idx</span><span class="p">)],</span>
            <span class="n">cooling_func</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">energy_report_idx</span><span class="p">[</span><span class="n">skip_first</span><span class="p">:])),</span>
        <span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__history</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">__history</span><span class="p">,</span> <span class="n">history</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">xarray_out</span><span class="p">:</span> 
            <span class="k">return</span> <span class="kc">None</span>
    
        <span class="c1"># convert the ds_out_dict to a single xarray.Dataset with an iteration dimension if requested</span>
        <span class="c1"># TODO: move this to a separate function???</span>
        
        <span class="c1"># if unwrapping is requested, the output rasters may have different shapes, so we need to find the max extent</span>
        <span class="c1"># across all reported arrays and create a new raster with that shape.</span>
        
        <span class="c1"># find the maximum extent of the unwrapped grid across all reported arrays</span>
        <span class="n">coord_ranges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="n">ds</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">ds</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">ds</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">ds</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">ds_out_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">min</span><span class="p">(</span><span class="n">coord_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord_range</span> <span class="ow">in</span> <span class="n">coord_ranges</span><span class="p">),</span> 
            <span class="nb">max</span><span class="p">(</span><span class="n">coord_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord_range</span> <span class="ow">in</span> <span class="n">coord_ranges</span><span class="p">),</span> 
            <span class="nb">min</span><span class="p">(</span><span class="n">coord_range</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord_range</span> <span class="ow">in</span> <span class="n">coord_ranges</span><span class="p">),</span> 
            <span class="nb">max</span><span class="p">(</span><span class="n">coord_range</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord_range</span> <span class="ow">in</span> <span class="n">coord_ranges</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">new_xcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">)</span>
        <span class="n">new_ycoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">)</span>

        <span class="n">data_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ds_out_dict</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_ycoords</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_xcoords</span><span class="p">))</span>

        <span class="c1"># build an empty dataset</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span>
            <span class="n">data_vars</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;energy_rasters&quot;</span><span class="p">:</span> <span class="p">(</span>
                    <span class="p">[</span><span class="s2">&quot;iteration&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">],</span> 
                    <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">data_shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="s2">&quot;area_rasters&quot;</span><span class="p">:</span> <span class="p">(</span>
                    <span class="p">[</span><span class="s2">&quot;iteration&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">],</span> 
                    <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">data_shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="s2">&quot;watershed_id&quot;</span><span class="p">:</span> <span class="p">(</span>
                    <span class="p">[</span><span class="s2">&quot;iteration&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">],</span> 
                    <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">data_shape</span><span class="p">,</span> <span class="o">-</span><span class="mi">9999</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="p">),</span>
            <span class="p">},</span>
            <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;iteration&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;iteration&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array_report_idx</span><span class="p">)),</span>
                <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">new_ycoords</span><span class="p">),</span>
                <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">new_xcoords</span><span class="p">),</span>
            <span class="p">},</span>
            <span class="n">attrs</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;OCN fit result arrays&quot;</span><span class="p">,</span>
                <span class="s2">&quot;resolution&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span>
                <span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span>
                <span class="s2">&quot;master_seed&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">),</span>
                <span class="s2">&quot;wrap&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>

        <span class="c1"># fill in the dataset with the unwrapped arrays, matching coordinates</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ds_i</span> <span class="ow">in</span> <span class="n">ds_out_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">energy_rasters</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">iteration</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">ds_i</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">ds_i</span><span class="o">.</span><span class="n">x</span><span class="p">)]</span> <span class="o">=</span> <span class="n">ds_i</span><span class="o">.</span><span class="n">energy_rasters</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">area_rasters</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">iteration</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">ds_i</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">ds_i</span><span class="o">.</span><span class="n">x</span><span class="p">)]</span> <span class="o">=</span> <span class="n">ds_i</span><span class="o">.</span><span class="n">area_rasters</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">watershed_id</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">iteration</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">ds_i</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">ds_i</span><span class="o">.</span><span class="n">x</span><span class="p">)]</span> <span class="o">=</span> <span class="n">ds_i</span><span class="o">.</span><span class="n">watershed_id</span>

        <span class="k">return</span> <span class="n">ds</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Alexander S. Fox.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>