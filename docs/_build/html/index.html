

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PyOCN Documentation &mdash; PyOCN 1.2.20251010 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=98efb7dd"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="#" class="icon icon-home">
            PyOCN
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">PyOCN Documentation</a></li>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#quick-start">Quick Start</a></li>
<li><a class="reference internal" href="#module-PyOCN">API Reference</a><ul>
<li><a class="reference internal" href="#PyOCN.OCN"><code class="docutils literal notranslate"><span class="pre">OCN</span></code></a><ul>
<li><a class="reference internal" href="#PyOCN.OCN.energy"><code class="docutils literal notranslate"><span class="pre">OCN.energy</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.OCN.dims"><code class="docutils literal notranslate"><span class="pre">OCN.dims</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.OCN.resolution"><code class="docutils literal notranslate"><span class="pre">OCN.resolution</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.OCN.nroots"><code class="docutils literal notranslate"><span class="pre">OCN.nroots</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.OCN.gamma"><code class="docutils literal notranslate"><span class="pre">OCN.gamma</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.OCN.master_seed"><code class="docutils literal notranslate"><span class="pre">OCN.master_seed</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.OCN.verbosity"><code class="docutils literal notranslate"><span class="pre">OCN.verbosity</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.OCN.wrap"><code class="docutils literal notranslate"><span class="pre">OCN.wrap</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.OCN.history"><code class="docutils literal notranslate"><span class="pre">OCN.history</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.OCN.compute_energy"><code class="docutils literal notranslate"><span class="pre">OCN.compute_energy()</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.OCN.copy"><code class="docutils literal notranslate"><span class="pre">OCN.copy()</span></code></a></li>
<li><a class="reference internal" href="#id0"><code class="docutils literal notranslate"><span class="pre">OCN.dims</span></code></a></li>
<li><a class="reference internal" href="#id1"><code class="docutils literal notranslate"><span class="pre">OCN.energy</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.OCN.fit"><code class="docutils literal notranslate"><span class="pre">OCN.fit()</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.OCN.fit_custom_cooling"><code class="docutils literal notranslate"><span class="pre">OCN.fit_custom_cooling()</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.OCN.from_digraph"><code class="docutils literal notranslate"><span class="pre">OCN.from_digraph()</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.OCN.from_net_type"><code class="docutils literal notranslate"><span class="pre">OCN.from_net_type()</span></code></a></li>
<li><a class="reference internal" href="#id2"><code class="docutils literal notranslate"><span class="pre">OCN.history</span></code></a></li>
<li><a class="reference internal" href="#id3"><code class="docutils literal notranslate"><span class="pre">OCN.nroots</span></code></a></li>
<li><a class="reference internal" href="#id4"><code class="docutils literal notranslate"><span class="pre">OCN.resolution</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.OCN.rng"><code class="docutils literal notranslate"><span class="pre">OCN.rng</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.OCN.single_iteration"><code class="docutils literal notranslate"><span class="pre">OCN.single_iteration()</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.OCN.to_digraph"><code class="docutils literal notranslate"><span class="pre">OCN.to_digraph()</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.OCN.to_gtiff"><code class="docutils literal notranslate"><span class="pre">OCN.to_gtiff()</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.OCN.to_numpy"><code class="docutils literal notranslate"><span class="pre">OCN.to_numpy()</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.OCN.to_xarray"><code class="docutils literal notranslate"><span class="pre">OCN.to_xarray()</span></code></a></li>
<li><a class="reference internal" href="#id5"><code class="docutils literal notranslate"><span class="pre">OCN.wrap</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#PyOCN.assign_subwatersheds"><code class="docutils literal notranslate"><span class="pre">assign_subwatersheds()</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.get_subwatersheds"><code class="docutils literal notranslate"><span class="pre">get_subwatersheds()</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.net_type_to_dag"><code class="docutils literal notranslate"><span class="pre">net_type_to_dag()</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.plot_ocn_as_dag"><code class="docutils literal notranslate"><span class="pre">plot_ocn_as_dag()</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.plot_ocn_raster"><code class="docutils literal notranslate"><span class="pre">plot_ocn_raster()</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.plot_positional_digraph"><code class="docutils literal notranslate"><span class="pre">plot_positional_digraph()</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.simulated_annealing_schedule"><code class="docutils literal notranslate"><span class="pre">simulated_annealing_schedule()</span></code></a></li>
<li><a class="reference internal" href="#PyOCN.unwrap_digraph"><code class="docutils literal notranslate"><span class="pre">unwrap_digraph()</span></code></a></li>
<li><a class="reference internal" href="#ocn-class">OCN Class</a><ul>
<li><a class="reference internal" href="#id6"><code class="docutils literal notranslate"><span class="pre">OCN</span></code></a><ul>
<li><a class="reference internal" href="#id11"><code class="docutils literal notranslate"><span class="pre">OCN.energy</span></code></a></li>
<li><a class="reference internal" href="#id12"><code class="docutils literal notranslate"><span class="pre">OCN.dims</span></code></a></li>
<li><a class="reference internal" href="#id13"><code class="docutils literal notranslate"><span class="pre">OCN.resolution</span></code></a></li>
<li><a class="reference internal" href="#id14"><code class="docutils literal notranslate"><span class="pre">OCN.nroots</span></code></a></li>
<li><a class="reference internal" href="#id15"><code class="docutils literal notranslate"><span class="pre">OCN.gamma</span></code></a></li>
<li><a class="reference internal" href="#id16"><code class="docutils literal notranslate"><span class="pre">OCN.master_seed</span></code></a></li>
<li><a class="reference internal" href="#id17"><code class="docutils literal notranslate"><span class="pre">OCN.verbosity</span></code></a></li>
<li><a class="reference internal" href="#id18"><code class="docutils literal notranslate"><span class="pre">OCN.wrap</span></code></a></li>
<li><a class="reference internal" href="#id19"><code class="docutils literal notranslate"><span class="pre">OCN.history</span></code></a></li>
<li><a class="reference internal" href="#id20"><code class="docutils literal notranslate"><span class="pre">OCN.compute_energy()</span></code></a></li>
<li><a class="reference internal" href="#id21"><code class="docutils literal notranslate"><span class="pre">OCN.copy()</span></code></a></li>
<li><a class="reference internal" href="#id22"><code class="docutils literal notranslate"><span class="pre">OCN.dims</span></code></a></li>
<li><a class="reference internal" href="#id23"><code class="docutils literal notranslate"><span class="pre">OCN.energy</span></code></a></li>
<li><a class="reference internal" href="#id24"><code class="docutils literal notranslate"><span class="pre">OCN.fit()</span></code></a></li>
<li><a class="reference internal" href="#id25"><code class="docutils literal notranslate"><span class="pre">OCN.fit_custom_cooling()</span></code></a></li>
<li><a class="reference internal" href="#id26"><code class="docutils literal notranslate"><span class="pre">OCN.from_digraph()</span></code></a></li>
<li><a class="reference internal" href="#id27"><code class="docutils literal notranslate"><span class="pre">OCN.from_net_type()</span></code></a></li>
<li><a class="reference internal" href="#id28"><code class="docutils literal notranslate"><span class="pre">OCN.history</span></code></a></li>
<li><a class="reference internal" href="#id29"><code class="docutils literal notranslate"><span class="pre">OCN.nroots</span></code></a></li>
<li><a class="reference internal" href="#id30"><code class="docutils literal notranslate"><span class="pre">OCN.resolution</span></code></a></li>
<li><a class="reference internal" href="#id31"><code class="docutils literal notranslate"><span class="pre">OCN.rng</span></code></a></li>
<li><a class="reference internal" href="#id32"><code class="docutils literal notranslate"><span class="pre">OCN.single_iteration()</span></code></a></li>
<li><a class="reference internal" href="#id33"><code class="docutils literal notranslate"><span class="pre">OCN.to_digraph()</span></code></a></li>
<li><a class="reference internal" href="#id34"><code class="docutils literal notranslate"><span class="pre">OCN.to_gtiff()</span></code></a></li>
<li><a class="reference internal" href="#id35"><code class="docutils literal notranslate"><span class="pre">OCN.to_numpy()</span></code></a></li>
<li><a class="reference internal" href="#id36"><code class="docutils literal notranslate"><span class="pre">OCN.to_xarray()</span></code></a></li>
<li><a class="reference internal" href="#id37"><code class="docutils literal notranslate"><span class="pre">OCN.wrap</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#plotting-functions">Plotting Functions</a><ul>
<li><a class="reference internal" href="#id38"><code class="docutils literal notranslate"><span class="pre">plot_ocn_raster()</span></code></a></li>
<li><a class="reference internal" href="#id39"><code class="docutils literal notranslate"><span class="pre">plot_ocn_as_dag()</span></code></a></li>
<li><a class="reference internal" href="#id40"><code class="docutils literal notranslate"><span class="pre">plot_positional_digraph()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">PyOCN</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">PyOCN Documentation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="pyocn-documentation">
<h1>PyOCN Documentation<a class="headerlink" href="#pyocn-documentation" title="Link to this heading"></a></h1>
<p>This is a package to generate optimal channel networks (OCNs), based on the algorithm described in Carraro et al. (2020). <em>Generation and application of river network analogues for use in ecology and evolution. Ecology and Evolution.</em> doi:10.1002/ece3.6479
and mirrors some of the functionality of the OCNet R package (https://lucarraro.github.io/OCNet/).</p>
</section>
<section id="installation">
<h1>Installation<a class="headerlink" href="#installation" title="Link to this heading"></a></h1>
<p>Install from PyPI:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip<span class="w"> </span>install<span class="w"> </span>pyocn
</pre></div>
</div>
<p>Or with optional raster and xarray support:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip<span class="w"> </span>install<span class="w"> </span>pyocn<span class="o">[</span>raster<span class="o">]</span>
</pre></div>
</div>
</section>
<section id="quick-start">
<h1>Quick Start<a class="headerlink" href="#quick-start" title="Link to this heading"></a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">PyOCN</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">po</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># Create an OCN from a predefined initial network type</span>
<span class="n">ocn</span> <span class="o">=</span> <span class="n">po</span><span class="o">.</span><span class="n">OCN</span><span class="o">.</span><span class="n">from_net_type</span><span class="p">(</span><span class="s2">&quot;I&quot;</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Optimize with simulated annealing</span>
<span class="n">ocn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">n_iterations</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Visualize</span>
<span class="n">po</span><span class="o">.</span><span class="n">plot_ocn_raster</span><span class="p">(</span><span class="n">ocn</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="module-PyOCN">
<span id="api-reference"></span><h1>API Reference<a class="headerlink" href="#module-PyOCN" title="Link to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="PyOCN.OCN">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">PyOCN.</span></span><span class="sig-name descname"><span class="pre">OCN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyOCN.OCN" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The main class for interacting with Optimized Channel Networks.</p>
<p>Use <a class="reference internal" href="#id27" title="PyOCN.OCN.from_net_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OCN.from_net_type()</span></code></a> or <a class="reference internal" href="#id26" title="PyOCN.OCN.from_digraph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OCN.from_digraph()</span></code></a> to construct an
instance.</p>
<section id="constructor-methods">
<h2>Constructor Methods<a class="headerlink" href="#constructor-methods" title="Link to this heading"></a></h2>
<dl class="simple">
<dt><a class="reference internal" href="#id27" title="PyOCN.OCN.from_net_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_net_type()</span></code></a></dt><dd><p>Create an OCN from a predefined network type and dimensions.</p>
</dd>
<dt><a class="reference internal" href="#id26" title="PyOCN.OCN.from_digraph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_digraph()</span></code></a></dt><dd><p>Create an OCN from an existing NetworkX DiGraph.</p>
</dd>
</dl>
</section>
<section id="export-methods">
<h2>Export Methods<a class="headerlink" href="#export-methods" title="Link to this heading"></a></h2>
<dl class="simple">
<dt><a class="reference internal" href="#id33" title="PyOCN.OCN.to_digraph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_digraph()</span></code></a></dt><dd><p>Export the current grid to a NetworkX DiGraph.</p>
</dd>
<dt><a class="reference internal" href="#id35" title="PyOCN.OCN.to_numpy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_numpy()</span></code></a></dt><dd><p>Export raster arrays (energy, drained area, watershed_id) as numpy arrays.</p>
</dd>
<dt><a class="reference internal" href="#id36" title="PyOCN.OCN.to_xarray"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_xarray()</span></code></a></dt><dd><p>Export raster arrays as an xarray Dataset (requires xarray).</p>
</dd>
<dt><a class="reference internal" href="#id34" title="PyOCN.OCN.to_gtiff"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_gtiff()</span></code></a></dt><dd><p>Export raster arrays to a GeoTIFF file (requires rasterio).</p>
</dd>
<dt><a class="reference internal" href="#id21" title="PyOCN.OCN.copy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code></a></dt><dd><p>Create a deep copy of the OCN.</p>
</dd>
</dl>
</section>
<section id="optimization-methods">
<h2>Optimization Methods<a class="headerlink" href="#optimization-methods" title="Link to this heading"></a></h2>
<dl class="simple">
<dt><code class="xref py py-meth docutils literal notranslate"><span class="pre">single_erosion_event()</span></code></dt><dd><p>Perform a single erosion event at a given temperature.</p>
</dd>
<dt><a class="reference internal" href="#id24" title="PyOCN.OCN.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a></dt><dd><p>Optimize the network using the simulated annealing method from Carraro et al (2020).</p>
</dd>
<dt><a class="reference internal" href="#id25" title="PyOCN.OCN.fit_custom_cooling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit_custom_cooling()</span></code></a></dt><dd><p>Optimize the network using a custom cooling function.</p>
</dd>
</dl>
</section>
<section id="other-methods">
<h2>Other methods<a class="headerlink" href="#other-methods" title="Link to this heading"></a></h2>
<dl class="simple">
<dt><a class="reference internal" href="#id20" title="PyOCN.OCN.compute_energy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_energy()</span></code></a></dt><dd><p>Compute the current energy of the network.</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="PyOCN.OCN.energy">
<span class="sig-name descname"><span class="pre">energy</span></span><a class="headerlink" href="#PyOCN.OCN.energy" title="Link to this definition"></a></dt>
<dd><p>Current energy of the network (read-only property).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="PyOCN.OCN.dims">
<span class="sig-name descname"><span class="pre">dims</span></span><a class="headerlink" href="#PyOCN.OCN.dims" title="Link to this definition"></a></dt>
<dd><p>Grid dimensions (rows, cols) of the FlowGrid (read-only property).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple[int, int]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="PyOCN.OCN.resolution">
<span class="sig-name descname"><span class="pre">resolution</span></span><a class="headerlink" href="#PyOCN.OCN.resolution" title="Link to this definition"></a></dt>
<dd><p>The side length of each grid cell (read-only property).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="PyOCN.OCN.nroots">
<span class="sig-name descname"><span class="pre">nroots</span></span><a class="headerlink" href="#PyOCN.OCN.nroots" title="Link to this definition"></a></dt>
<dd><p>Number of root nodes in the current OCN grid (read-only property).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="PyOCN.OCN.gamma">
<span class="sig-name descname"><span class="pre">gamma</span></span><a class="headerlink" href="#PyOCN.OCN.gamma" title="Link to this definition"></a></dt>
<dd><p>Exponent in the energy model.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="PyOCN.OCN.master_seed">
<span class="sig-name descname"><span class="pre">master_seed</span></span><a class="headerlink" href="#PyOCN.OCN.master_seed" title="Link to this definition"></a></dt>
<dd><p>The seed used to initialize the internal RNG.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="PyOCN.OCN.verbosity">
<span class="sig-name descname"><span class="pre">verbosity</span></span><a class="headerlink" href="#PyOCN.OCN.verbosity" title="Link to this definition"></a></dt>
<dd><p>Verbosity level for underlying library output (0-2).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="PyOCN.OCN.wrap">
<span class="sig-name descname"><span class="pre">wrap</span></span><a class="headerlink" href="#PyOCN.OCN.wrap" title="Link to this definition"></a></dt>
<dd><p>If true, enables periodic boundary conditions on the FlowGrid (read-only property).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="PyOCN.OCN.history">
<span class="sig-name descname"><span class="pre">history</span></span><a class="headerlink" href="#PyOCN.OCN.history" title="Link to this definition"></a></dt>
<dd><p>numpy array of shape (n_iterations, 3) recording the iteration index, energy, and temperature at each iteration during optimization.
Updated each time an optimization method is called.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Examples</p>
<p>The following is a simple example of creating, optimizing, and plotting
an OCN using PyOCN and Matplotlib. More examples are available in the
<cite>demo.ipynb</cite> notebook in the repository (<a class="reference external" href="https://github.com/alextsfox/PyOCN">https://github.com/alextsfox/PyOCN</a>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Fit an OCN from a &quot;Hip-roof&quot; initial network shape and periodic boundary conditions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">mpl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">PyOCN</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">po</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ocn</span> <span class="o">=</span> <span class="n">po</span><span class="o">.</span><span class="n">OCN</span><span class="o">.</span><span class="n">from_net_type</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">8472</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ocn</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">po</span><span class="o">.</span><span class="n">plot_ocn_raster</span><span class="p">(</span><span class="n">ocn</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">PowerNorm</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">attribute</span><span class="o">=</span><span class="s1">&#39;drained_area&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="PyOCN.OCN.compute_energy">
<span class="sig-name descname"><span class="pre">compute_energy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.compute_energy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyOCN.OCN.compute_energy" title="Link to this definition"></a></dt>
<dd><p>Compute the current energy of the network.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The computed energy value.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This constructs a temporary <code class="docutils literal notranslate"><span class="pre">DiGraph</span></code> view to aggregate node
energies from drained areas using the exponent <code class="docutils literal notranslate"><span class="pre">gamma</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyOCN.OCN.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyOCN.OCN.copy" title="Link to this definition"></a></dt>
<dd><p>Create a deep copy of the OCN, including the underlying FlowGrid_C.
Also copies the current RNG state. The new copy and the original
will be independent from each other and behave identically statistically.</p>
<dl class="field-list simple">
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="id0">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dims</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#id0" title="Link to this definition"></a></dt>
<dd><p>Grid dimensions of the FlowGrid (read-only).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(rows,</span> <span class="pre">cols)</span></code>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[int, int]</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="id1">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">energy</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#id1" title="Link to this definition"></a></dt>
<dd><p>Energy of the current OCN.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Current energy.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyOCN.OCN.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cooling_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant_phase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_reports</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iterations_per_loop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unwrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyOCN.OCN.fit" title="Link to this definition"></a></dt>
<dd><p>Convenience function to optimize the OCN using the simulated annealing algorithm from Carraro et al (2020).
For finer control over the optimization process, use <a class="reference internal" href="#id25" title="PyOCN.OCN.fit_custom_cooling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit_custom_cooling()</span></code></a> or use <code class="xref py py-meth docutils literal notranslate"><span class="pre">single_erosion_event()</span></code> in a loop.</p>
<p>This performs <code class="docutils literal notranslate"><span class="pre">n_iterations</span></code> erosion events, accepting or rejecting
proposals according to a temperature schedule defined by the annealing algorithm.
A proposal consists of changing the outflow direction of a randomly selected vertex.
The new outflow direction is chosen uniformly from the valid neighbors.
A proposal is valid if it maintains a well-formed graph structure.</p>
<p>The <a class="reference internal" href="#id28" title="PyOCN.OCN.history"><code class="xref py py-attr docutils literal notranslate"><span class="pre">history</span></code></a> attribute is updated in-place after optimization finishes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ocn</strong> (<a class="reference internal" href="#id6" title="PyOCN.OCN"><em>OCN</em></a>) – The OCN instance to optimize.</p></li>
<li><p><strong>cooling_rate</strong> (<em>float</em><em>, </em><em>default 1.0</em>) – Cooling rate parameter in the annealing algorithm. Typical range is 0.5-1.5.
Higher values result in faster cooling and a greedier search.
Lower values result in slower cooling and more thorough exploration of the solution space, but slower convergence and lower stability.</p></li>
<li><p><strong>constant_phase</strong> (<em>float</em><em>, </em><em>default 0.0</em>) – Amount of time to hold temeprature constant at the start of the optimization.
This is a fraction of n_iterations, and must be in the range [0, 1].
A value of 0.0 (default) means the temperature starts cooling immediately
from the initial temperature. A value of 1.0 means the temperature is held
constant for the entire optimization.</p></li>
<li><p><strong>n_iterations</strong> (<em>int</em><em>, </em><em>optional</em>) – Total number of iterations. Defaults to <code class="docutils literal notranslate"><span class="pre">40</span> <span class="pre">*</span> <span class="pre">rows</span> <span class="pre">*</span> <span class="pre">cols</span></code>.
Always at least <code class="docutils literal notranslate"><span class="pre">energy_reports</span> <span class="pre">*</span> <span class="pre">10</span></code> (this should only matter for
extremely small grids, where <code class="docutils literal notranslate"><span class="pre">rows</span> <span class="pre">*</span> <span class="pre">cols</span> <span class="pre">&lt;</span> <span class="pre">256</span></code>).</p></li>
<li><p><strong>pbar</strong> (<em>bool</em><em>, </em><em>default True</em>) – Whether to display a progress bar.</p></li>
<li><p><strong>array_reports</strong> (<em>int</em><em>, </em><em>default 0</em>) – <p>Number of timepoints (approximately) at which to save the state of the FlowGrid.
If 0 (default), returns None. If &gt;0, returns an xarray.Dataset
containing the state of the FlowGrid at approximately evenly spaced intervals
throughout the optimization, including the initial and final states. Requires xarray to be installed.</p>
<dl class="simple">
<dt>The returned xarray.Dataset will have coordinates:</dt><dd><ul>
<li><p><cite>y</cite> (float) representing the northing coordinate of each row</p></li>
<li><p><cite>x</cite> (float) representing the easting coordinate of each column</p></li>
<li><p><cite>iteration</cite> (int) representing the iteration index at which the data was recorded</p></li>
</ul>
</dd>
<dt>data variables:</dt><dd><ul>
<li><p><cite>energy_rasters</cite> (np.float64) representing energy at each grid cell</p></li>
<li><p><cite>area_rasters</cite> (np.float64) representing drained area at each grid cell</p></li>
<li><p><cite>watershed_id</cite> (np.int32). NA value is -9999. Roots have value -1. Represents the watershed membership ID for each grid cell.</p></li>
</ul>
</dd>
</dl>
<p>The coordiante (0, 0) is the top-left corner of the grid.</p>
<dl>
<dt>If the OCN has a periodic boundary condition, the following changes apply:</dt><dd><ul>
<li><p>The (0,0) coordinate will be set to the position of the “main” root node, defined as</p></li>
</ul>
<p>the root node with the smallest row*cols + col value
- The rasters will be unwrapped to a non-periodic representation, which may result in larger rasters.
- The size of the final rasters are the maximum extent of the unwrapped grid, taken across all iterations.</p>
</dd>
</dl>
<p>Generating reports requires additional memory and computation time.</p>
</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – If provided, optimization will stop early if the relative change
in energy between reports is less than <cite>tol</cite>. Must be positive.
If None (default), no early stopping is performed.
Recommended values are in the range 1e-4 to 1e-6.</p></li>
<li><p><strong>max_iterations_per_loop</strong> (<em>int</em><em>, </em><em>optional</em>) – If provided, the number of iterations steps to perform in each “chunk”
of optimization. Energy and output arrays can be reported no more often
than this. Recommended values are 1_000-1_000_000. Default is 10_000.</p></li>
<li><p><strong>unwrap</strong> (<em>bool</em><em>, </em><em>default True</em>) – If True and the current OCN has periodic boundaries, the
resulting rasters will be transformed so connected grid cells
are adjacent in the output. This will result in a larger raster
with some nan values. If False or the current OCN does not have
periodic boundaries, then no transformation is applied and the
resulting raster will have the same dimensions as the current OCN grid.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>xr.Dataset | None</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – </p>
</dd>
<dt class="field-even">Warns<span class="colon">:</span></dt>
<dd class="field-even"><ul>
<li><p><strong>UserWarning</strong></p></li>
<li><p><strong>Optimization Algorithm</strong></p></li>
<li><p><strong>———————-</strong></p></li>
<li><p><strong>At iteration ``i``, the outflow of a random grid cell if proposed to be rerouted.</strong></p></li>
<li><p><strong>The proposal is accepted with the probability</strong></p></li>
<li><p><strong>.. math::</strong> – P(  ext{accept}) = e^{-Delta E / T},</p></li>
<li><p><strong>where :math:`Delta E` is the change in energy the change would cause</strong></p></li>
<li><p><strong>and :math:`T` is the temperature of the network.</strong></p></li>
<li><p><strong>The total energy of the system is computed from the drained areas of each grid cell :math:`k` as</strong></p></li>
<li><p><strong>.. math::</strong> – E = sum_k A_k^gamma</p></li>
<li><p><strong>The temperature of the network is governed by a cooling schedule, which is a function of iteration index.</strong></p></li>
<li><p><strong>Note that when :math:`Delta E &lt; 0`, the move is always accepted.</strong></p></li>
<li><p><strong>Simulated Annealing Schedule</strong></p></li>
<li><p><strong>—————————-</strong></p></li>
<li><p><strong>The cooling schedule used by this method is a piecewise function of iteration index</strong></p></li>
<li><p><strong>.. math::</strong> –</p>
<dl class="simple">
<dt>T(i) = egin{cases}</dt><dd><p>E_0 &amp; i &lt; C N E_0 cdot e^{;i - C N} &amp; i ge C N</p>
</dd>
</dl>
<p>end{cases}</p>
</li>
<li><p><strong>where :math:`E_0` is the initial energy, :math:`N` is the total number</strong></p></li>
<li><p><strong>of iterations, and :math:`C` is ``constant_phase``. Decreasing-energy</strong></p></li>
<li><p><strong>moves (:math:`Delta E &lt; 0`) are always accepted.</strong></p></li>
<li><p><strong>Alternative cooling schedules can be implemented using :meth:`fit_custom_cooling`.</strong></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyOCN.OCN.fit_custom_cooling">
<span class="sig-name descname"><span class="pre">fit_custom_cooling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cooling_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iteration_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_reports</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iterations_per_loop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unwrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.fit_custom_cooling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyOCN.OCN.fit_custom_cooling" title="Link to this definition"></a></dt>
<dd><p>Optimize the OCN using the a custom cooling schedule. This allows for
multi-stage optimizations or other custom cooling schedules not covered by the default simulated annealing schedule
from Carraro et al (2020).</p>
<p>See <a class="reference internal" href="#id24" title="PyOCN.OCN.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> for additional details on the optimization algorithm and parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ocn</strong> (<a class="reference internal" href="#id6" title="PyOCN.OCN"><em>OCN</em></a>) – The OCN instance to optimize.</p></li>
<li><p><strong>cooling_func</strong> (<em>Callable</em><em>[</em><em>[</em><em>np.ndarray</em><em>]</em><em>, </em><em>np.ndarray</em><em>]</em>) – A function that takes an array of iteration indices and returns an array of temperatures.
This function defines the cooling schedule for the optimization. Note that the function
should return temperatures that are appropriate for the current energy of the OCN.</p></li>
<li><p><strong>n_iterations</strong> (<em>int</em><em>, </em><em>optional</em>)</p></li>
<li><p><strong>iteration_start</strong> (<em>int</em><em>, </em><em>default 0</em>) – The starting iteration index. This is useful for continuing an optimization
from a previous run. Must be a non-negative integer. If provided, <code class="docutils literal notranslate"><span class="pre">n_iterations</span></code>
is the number of additional iterations to perform. The iteration number passed to
<code class="docutils literal notranslate"><span class="pre">cooling_func</span></code> will be <code class="docutils literal notranslate"><span class="pre">iteration_start</span> <span class="pre">+</span> <span class="pre">i</span></code> where <code class="docutils literal notranslate"><span class="pre">i</span></code> is the current iteration index
in the range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">n_iterations-1]</span></code>.</p></li>
<li><p><strong>pbar</strong> (<em>bool</em><em>, </em><em>default True</em>)</p></li>
<li><p><strong>array_reports</strong> (<em>int</em><em>, </em><em>default 0</em>)</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>)</p></li>
<li><p><strong>max_iterations_per_loop</strong> (<em>int</em><em>, </em><em>optional</em>)</p></li>
<li><p><strong>unwrap</strong> (<em>bool</em><em>, </em><em>default True</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>xr.Dataset | None</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – </p>
</dd>
<dt class="field-even">Warns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>UserWarning</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyOCN.OCN.from_digraph">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_digraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.from_digraph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyOCN.OCN.from_digraph" title="Link to this definition"></a></dt>
<dd><p>Create an <a class="reference internal" href="#id6" title="PyOCN.OCN"><code class="xref py py-class docutils literal notranslate"><span class="pre">OCN</span></code></a> from an existing NetworkX <code class="docutils literal notranslate"><span class="pre">DiGraph</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dag</strong> (<em>nx.DiGraph</em>) – Directed acyclic graph (DAG) representing the stream network.</p></li>
<li><p><strong>resolution</strong> (<em>int</em><em>, </em><em>optional</em>) – The side length of each grid cell.</p></li>
<li><p><strong>gamma</strong> (<em>float</em><em>, </em><em>default 0.5</em>) – Exponent in the energy model.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em> | </em><em>numpy.random.Generator</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Seed or generator for RNG seeding.</p></li>
<li><p><strong>verbosity</strong> (<em>int</em><em>, </em><em>default 0</em>) – Verbosity level (0-2) for underlying library output.</p></li>
<li><p><strong>wrap</strong> (<em>bool</em><em>, </em><em>default False</em>) – If true, allows wrapping around the edges of the grid (toroidal). If false, no wrapping is applied.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A newly constructed instance encapsulating the provided graph.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#id6" title="PyOCN.OCN">OCN</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The input graph must satisfy all of the following:</p>
<ul class="simple">
<li><p>It is a directed acyclic graph (DAG).</p></li>
<li><p>Each node has attribute <code class="docutils literal notranslate"><span class="pre">pos=(row:int,</span> <span class="pre">col:int)</span></code> specifying its
grid position with non-negative coordinates. Any other attributes
are ignored.</p></li>
<li><p>The graph can be partitioned into one or more spanning trees over
a dense grid of shape <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n)</span></code>: each grid cell corresponds to
exactly one node; each non-root node has <code class="docutils literal notranslate"><span class="pre">out_degree</span> <span class="pre">==</span> <span class="pre">1</span></code>;
the roots have <code class="docutils literal notranslate"><span class="pre">out_degree</span> <span class="pre">==</span> <span class="pre">0</span></code>.</p></li>
<li><p>Edges connect only to one of the 8 neighbors (cardinal or diagonal),
i.e., no jumps over rows or columns. If <code class="docutils literal notranslate"><span class="pre">wrap=True</span></code>, edges may
connect across the grid boundaries (i.e. row 0 can connect to row m-1 and col 0 can connect to col n-1).</p></li>
<li><p>Edges do not cross in the row-column plane.</p></li>
<li><p>Both <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code> are positive integers, and there are at least four
vertices.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># creating a &quot;zig-zag&quot; network</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># O O O O</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># |/|/|/|</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># O O O X</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">PyOCN</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">po</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">mpl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">dag</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">4</span><span class="p">,</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">:</span> <span class="n">dag</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ocn</span> <span class="o">=</span> <span class="n">OCN</span><span class="o">.</span><span class="n">from_digraph</span><span class="p">(</span><span class="n">dag</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">8472</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ocn</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">po</span><span class="o">.</span><span class="n">plot_ocn_raster</span><span class="p">(</span><span class="n">ocn</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">PowerNorm</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">attribute</span><span class="o">=</span><span class="s1">&#39;drained_area&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyOCN.OCN.from_net_type">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_net_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.from_net_type"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyOCN.OCN.from_net_type" title="Link to this definition"></a></dt>
<dd><p>Create an <a class="reference internal" href="#id6" title="PyOCN.OCN"><code class="xref py py-class docutils literal notranslate"><span class="pre">OCN</span></code></a> from a predefined network type and dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net_type</strong> (<em>str</em>) – Predefined network type to instantiate from. Valid types are “H”, “I”, “E”, and “V”. See
<code class="xref py py-func docutils literal notranslate"><span class="pre">net_type_to_dag()</span></code> for more information.</p></li>
<li><p><strong>dims</strong> (<em>tuple</em><em>[</em><em>int</em><em>, </em><em>int</em><em>]</em>) – Grid dimensions (rows, cols). Both must be positive even integers.</p></li>
<li><p><strong>resolution</strong> (<em>int</em><em>, </em><em>optional</em>) – The side length of each grid cell.</p></li>
<li><p><strong>gamma</strong> (<em>float</em><em>, </em><em>default 0.5</em>) – Exponent in the energy model.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em> | </em><em>numpy.random.Generator</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Seed or generator for RNG seeding.</p></li>
<li><p><strong>verbosity</strong> (<em>int</em><em>, </em><em>default 0</em>) – Verbosity level (0-2) for underlying library output.</p></li>
<li><p><strong>wrap</strong> (<em>bool</em><em>, </em><em>default False</em>) – If true, allows wrapping around the edges of the grid (toroidal). If false, no wrapping is applied.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A newly constructed instance initialized from the specified
network type and dimensions.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#id6" title="PyOCN.OCN">OCN</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="id2">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">history</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span></em><a class="headerlink" href="#id2" title="Link to this definition"></a></dt>
<dd><p>numpy array of shape (n_iterations, 3) recording the iteration index, energy, and temperature at each iteration during optimization.
If multiple fit calls are made, history is appended to this array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The optimization history.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="id3">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nroots</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#id3" title="Link to this definition"></a></dt>
<dd><p>Number of root nodes in the current OCN grid (read-only).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Current number of root nodes.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="id4">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">resolution</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#id4" title="Link to this definition"></a></dt>
<dd><p>Resolution of the current OCN grid in m (read-only).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Current resolution.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="PyOCN.OCN.rng">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rng</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#PyOCN.OCN.rng" title="Link to this definition"></a></dt>
<dd><p>returns: the current random state of the internal RNG as four 32-bit unsigned integers.
:rtype: tuple[int, int, int, int]</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyOCN.OCN.single_iteration">
<span class="sig-name descname"><span class="pre">single_iteration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">temperature</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_report</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unwrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.single_iteration"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyOCN.OCN.single_iteration" title="Link to this definition"></a></dt>
<dd><p>Perform a single iteration of the optimization algorithm at a given temperature. Updates the internal history attribute.
See <a class="reference internal" href="#id24" title="PyOCN.OCN.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> for details on the algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>temperature</strong> (<em>float</em>) – Temperature parameter governing acceptance probability. Typical
range is a fraction of ocn.energy.</p></li>
<li><p><strong>array_report</strong> (<em>bool</em><em>, </em><em>default False</em>) – If True (default), the returned result will be an xarray.Dataset.
See <a class="reference internal" href="#id24" title="PyOCN.OCN.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> for details. The returned object will have an iteration dimension of size 1.
Requires xarray to be installed.</p></li>
<li><p><strong>unwrap</strong> (<em>bool</em><em>, </em><em>default True</em>) – If True and the current OCN has periodic boundaries, the
resulting rasters will be transformed so connected grid cells
are adjacent in the output. This will result in a larger raster
with some nan values. If False or the current OCN does not have
periodic boundaries, then no transformation is applied and the
resulting raster will have the same dimensions as the current OCN grid.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>LibOCNError</strong> – If the underlying C routine reports an error status.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyOCN.OCN.to_digraph">
<span class="sig-name descname"><span class="pre">to_digraph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.to_digraph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyOCN.OCN.to_digraph" title="Link to this definition"></a></dt>
<dd><p>Create a NetworkX <code class="docutils literal notranslate"><span class="pre">DiGraph</span></code> view of the current grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>A DAG with the following node attributes per node:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pos</span></code>: <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> grid position</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">drained_area</span></code>: drained area value</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">energy</span></code>: cumulative energy at the node</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">watershed_id</span></code>: integer watershed ID (roots have watershed id = -1)</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>nx.DiGraph</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyOCN.OCN.to_gtiff">
<span class="sig-name descname"><span class="pre">to_gtiff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">west</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">north</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unwrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.to_gtiff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyOCN.OCN.to_gtiff" title="Link to this definition"></a></dt>
<dd><p>Export a raster of the current FlowGrid to a GeoTIFF file
using rasterio. The resulting raster has 3 bands: <cite>energy</cite>, <cite>drained_area</cite>, and <cite>watershed_id</cite>.
The <cite>watershed_id</cite> band contains integer watershed IDs assigned to each node,
with root nodes assigned a value of -1. NA values are either np.nan (for energy and drained_area)
or -9999 (for watershed_id).</p>
<p>N.B. This uses the <a class="reference internal" href="#id30" title="PyOCN.OCN.resolution"><code class="xref py py-attr docutils literal notranslate"><span class="pre">resolution</span></code></a> attribute to set pixel size in the raster.
This function does not check for unit compatibility, so it is up to the user
to ensure the resolution and CRS units match. By default,
the resolution is set to 1.0. Using a CRS with degree units in this case
would result in a pixel size of 1 degree, which is likely not what you want.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>west</strong> (<em>float</em>) – The western border of the raster in crs units, corresponding
to column 0.</p></li>
<li><p><strong>north</strong> (<em>float</em>) – The northern border of the raster in crs units, corresponding
to row 0.</p></li>
<li><p><strong>crs</strong> (<em>Any</em>) – The crs for the resulting gtiff, passed to <cite>rasterio.open</cite></p></li>
<li><p><strong>path</strong> (<em>str</em><em> or </em><em>Pathlike</em>) – The output path for the resulting gtiff file.</p></li>
<li><p><strong>unwrap</strong> (<em>bool</em><em>, </em><em>default True</em>) – If True and the current OCN has periodic boundaries, the
resulting raster will be transformed so connected grid cells
are adjacent in the raster. This will result in a larger raster
with some nan values. If False or the current OCN does not have
periodic boundaries, then no transformation is applied and the
raster will have the same dimensions as the current OCN grid.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyOCN.OCN.to_numpy">
<span class="sig-name descname"><span class="pre">to_numpy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unwrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.to_numpy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyOCN.OCN.to_numpy" title="Link to this definition"></a></dt>
<dd><p>Export the current FlowGrid to a numpy array with shape (2, rows, cols).
Has two channels: 0=energy, 1=drained_area.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>unwrap</strong> (<em>bool</em><em>, </em><em>default True</em>) – If True and the current OCN has periodic boundaries, the
resulting array will be transformed so connected grid cells
are adjacent in the array. This will result in a larger array
with some nan values. If False or the current OCN does not have
periodic boundaries, then no transformation is applied and the
resulting array will have the same dimensions as the current OCN grid.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="PyOCN.OCN.to_xarray">
<span class="sig-name descname"><span class="pre">to_xarray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unwrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.to_xarray"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyOCN.OCN.to_xarray" title="Link to this definition"></a></dt>
<dd><p>Export the current FlowGrid to an xarray Dataset</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>unwrap</strong> (<em>bool</em><em>, </em><em>default True</em>) – <p>If True and the current OCN has periodic boundaries, the
resulting rasters will be transformed so connected grid cells
are adjacent in the output. This will result in a larger raster
with some nan values. If False or the current OCN does not have
periodic boundaries, then no transformation is applied and the
resulting raster will have the same dimensions as the current OCN grid.</p>
<p>When unwrapping, the (0,0) coordinate
will be set to the position of the “main” root node, defined as
the root node with the smallest row*cols + col value. Otherwise,
(0,0) will be the top-left corner of the grid.</p>
</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul>
<li><p><em>xr.Dataset</em> –</p>
<dl class="simple">
<dt>an xarray Dataset with data variables:</dt><dd><ul class="simple">
<li><p><cite>energy_rasters</cite> (np.float64) representing energy at each grid cell</p></li>
<li><p><cite>area_rasters</cite> (np.float64) representing drained area at each grid cell</p></li>
<li><p><cite>watershed_id</cite> (np.int32). NA value is -9999. Roots have value -1. Represents the watershed membership ID for each grid cell.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p><em>and coordinates</em> –</p>
<ul class="simple">
<li><p><cite>y</cite> (float) representing the northing coordinate of each row.</p></li>
<li><p><cite>x</cite> (float) representing the easting coordinate of each column.</p></li>
</ul>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>xr.Dataset</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="id5">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">wrap</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#id5" title="Link to this definition"></a></dt>
<dd><p>Whether the grid allows wrapping around the edges (toroidal).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Current wrap setting.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

</section>
<dl class="field-list simple">
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyOCN.assign_subwatersheds">
<span class="sig-prename descclassname"><span class="pre">PyOCN.</span></span><span class="sig-name descname"><span class="pre">assign_subwatersheds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dag</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/utils.html#assign_subwatersheds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyOCN.assign_subwatersheds" title="Link to this definition"></a></dt>
<dd><p>Assign a ‘watershed_id’ attribute to each node in the DAG.
The resulting watershed_ids will be of the highest order possible,
meaning that ids are assigned based on watersheds that drain directly into the
root nodes of the graph. To assign ids to lower order watersheds, consider first
partitioning the graph into smaller subgraphs using the <cite>get_subwatersheds</cite> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dag</strong> (<em>nx.DiGraph</em>) – The input directed acyclic graph. Each node must have a ‘pos’ attribute
indicating its (row, col) position.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The function modifies the input graph in place by adding a ‘watershed_id’
attribute to each node.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If any node in the input graph lacks a ‘pos’ attribute.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>A subwatershed is defined as the set of nodes that drain to a common outlet,
where an outlet is a node with out-degree zero. Each subwatershed is assigned
a unique integer ID, starting from 0. Nodes that are outlets themselves are
assigned a watershed ID of -1.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyOCN.get_subwatersheds">
<span class="sig-prename descclassname"><span class="pre">PyOCN.</span></span><span class="sig-name descname"><span class="pre">get_subwatersheds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/utils.html#get_subwatersheds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyOCN.get_subwatersheds" title="Link to this definition"></a></dt>
<dd><p>Extract subwatershed subgraphs from the main DAG. Each subwatershed drains to a common outlet node <cite>node</cite>.
Node <cite>node</cite> is not included in the returned subwatershed graphs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dag</strong> (<em>nx.DiGraph</em>) – The input directed acyclic graph. Each node must have a ‘pos’ attribute
indicating its (row, col) position.</p></li>
<li><p><strong>node</strong> (<em>Any</em>) – A node in the graph representing the outlet of a subwatershed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A set of directed acyclic graphs, each representing a subwatershed.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>set of nx.DiGraph</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The returned subwatersheds are subgraph views of the input graph and share node
and edge data with the original graph. Unless copied, any changes to node or edge attributes
in the subwatersheds will affect the original graph.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyOCN.net_type_to_dag">
<span class="sig-prename descclassname"><span class="pre">PyOCN.</span></span><span class="sig-name descname"><span class="pre">net_type_to_dag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/utils.html#net_type_to_dag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyOCN.net_type_to_dag" title="Link to this definition"></a></dt>
<dd><p>Create a predefined OCN initialization network as a NetworkX DiGraph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>net_type</strong> – <p>The type of network to create.
Descriptions of allowed types:</p>
<ul>
<li><p>”I”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">O</span><span class="o">--</span><span class="n">O</span><span class="o">--</span><span class="n">O</span><span class="o">--</span><span class="n">O</span><span class="o">--</span><span class="n">O</span>
      <span class="o">|</span>
<span class="n">O</span><span class="o">--</span><span class="n">O</span><span class="o">--</span><span class="n">O</span><span class="o">--</span><span class="n">O</span><span class="o">--</span><span class="n">O</span>
      <span class="o">|</span>
<span class="n">O</span><span class="o">--</span><span class="n">O</span><span class="o">--</span><span class="n">O</span><span class="o">--</span><span class="n">O</span><span class="o">--</span><span class="n">O</span>
      <span class="o">|</span>
<span class="n">O</span><span class="o">--</span><span class="n">O</span><span class="o">--</span><span class="n">X</span><span class="o">--</span><span class="n">O</span><span class="o">--</span><span class="n">O</span>
</pre></div>
</div>
</li>
<li><p>”V”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">O</span>  <span class="n">O</span>  <span class="n">O</span>  <span class="n">O</span>  <span class="n">O</span>
 \  \ <span class="o">|</span> <span class="o">/</span>  <span class="o">/</span>
<span class="n">O</span>  <span class="n">O</span>  <span class="n">O</span>  <span class="n">O</span>  <span class="n">O</span>
 \  \ <span class="o">|</span> <span class="o">/</span>  <span class="o">/</span>
<span class="n">O</span>  <span class="n">O</span>  <span class="n">O</span>  <span class="n">O</span>  <span class="n">O</span>
 \  \ <span class="o">|</span> <span class="o">/</span>  <span class="o">/</span>
<span class="n">O</span><span class="o">--</span><span class="n">O</span><span class="o">--</span><span class="n">X</span><span class="o">--</span><span class="n">O</span><span class="o">--</span><span class="n">O</span>
</pre></div>
</div>
</li>
<li><p>”H”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">O</span>  <span class="n">O</span>  <span class="n">O</span>  <span class="n">O</span>
<span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span> <span class="o">/</span>
<span class="n">O</span>  <span class="n">O</span>  <span class="n">O</span><span class="o">--</span><span class="n">O</span>
<span class="o">|</span>  <span class="o">|</span> <span class="o">/</span>
<span class="n">O</span>  <span class="n">O</span><span class="o">--</span><span class="n">O</span><span class="o">--</span><span class="n">O</span>
<span class="o">|</span> <span class="o">/</span>
<span class="n">X</span><span class="o">--</span><span class="n">O</span><span class="o">--</span><span class="n">O</span><span class="o">--</span><span class="n">O</span>
</pre></div>
</div>
</li>
<li><p>”E”: A network where every node on the edge of the grid is a root.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span>  <span class="n">X</span>  <span class="n">X</span>  <span class="n">X</span>  <span class="n">X</span>  <span class="n">X</span>
  \  \    <span class="o">/</span>  <span class="o">/</span>
<span class="n">X</span>  <span class="n">O</span>  <span class="n">O</span>  <span class="n">O</span>  <span class="n">O</span>  <span class="n">X</span>
  \  \    <span class="o">/</span>  <span class="o">/</span>
<span class="n">X</span>  <span class="n">O</span>  <span class="n">O</span>  <span class="n">O</span>  <span class="n">O</span>  <span class="n">X</span>

<span class="n">X</span>  <span class="n">O</span>  <span class="n">O</span>  <span class="n">O</span>  <span class="n">O</span>  <span class="n">X</span>
  <span class="o">/</span>  <span class="o">/</span>     \                <span class="n">X</span>  <span class="n">O</span>  <span class="n">O</span>  <span class="n">O</span>  <span class="n">O</span>  <span class="n">X</span>
  <span class="o">/</span>  <span class="o">/</span>     \  \
<span class="n">X</span>  <span class="n">X</span>  <span class="n">X</span>  <span class="n">X</span>  <span class="n">X</span>  <span class="n">X</span>
</pre></div>
</div>
</li>
</ul>
</p>
</dd>
</dl>
<dl class="simple">
<dt>dims<span class="classifier">tuple</span></dt><dd><p>The network dimensions as <code class="docutils literal notranslate"><span class="pre">(rows,</span> <span class="pre">cols)</span></code>. Both must be positive even integers.</p>
</dd>
<dt>pbar<span class="classifier">bool, default False</span></dt><dd><p>If True, display a progress bar while constructing the graph.</p>
</dd>
<dt>wrap<span class="classifier">bool, default False</span></dt><dd><p>If True, create the graph with periodic boundary conditions (toroidal).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A directed acyclic graph representing a valid initial OCN configuration.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>networkx.DiGraph</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If <code class="docutils literal notranslate"><span class="pre">net_type</span></code> is invalid or <code class="docutils literal notranslate"><span class="pre">dims</span></code> are not two positive even integers.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The returned graph assigns each grid cell exactly one node with a <code class="docutils literal notranslate"><span class="pre">pos</span></code>
attribute equal to <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyOCN.plot_ocn_as_dag">
<span class="sig-prename descclassname"><span class="pre">PyOCN.</span></span><span class="sig-name descname"><span class="pre">plot_ocn_as_dag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ocn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attribute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/plotting.html#plot_ocn_as_dag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyOCN.plot_ocn_as_dag" title="Link to this definition"></a></dt>
<dd><p>Plot the OCN as a DAG using NetworkX.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ocn</strong> (<a class="reference internal" href="#id6" title="PyOCN.OCN"><em>OCN</em></a>) – The OCN instance to plot.</p></li>
<li><p><strong>attribute</strong> (<em>str</em><em>, </em><em>optional</em>) – Node attribute name for coloring (e.g., <code class="docutils literal notranslate"><span class="pre">'drained_area'</span></code> or
<code class="docutils literal notranslate"><span class="pre">'energy'</span></code>). If omitted, a uniform color is used.</p></li>
<li><p><strong>ax</strong> (<em>matplotlib.axes.Axes</em><em>, </em><em>optional</em>) – Target axes. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, a new figure and axes are created.</p></li>
<li><p><strong>norm</strong> (<em>matplotlib.colors.Normalize</em><em>, </em><em>optional</em>) – Normalization to apply to node colors when <code class="docutils literal notranslate"><span class="pre">attribute</span></code> is provided.
If specified, any <code class="docutils literal notranslate"><span class="pre">vmin</span></code>/<code class="docutils literal notranslate"><span class="pre">vmax</span></code> passed in <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> are ignored.</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments forwarded to
<code class="xref py py-func docutils literal notranslate"><span class="pre">networkx.draw_networkx()</span></code> (e.g., <code class="docutils literal notranslate"><span class="pre">cmap</span></code>, <code class="docutils literal notranslate"><span class="pre">vmin</span></code>, <code class="docutils literal notranslate"><span class="pre">vmax</span></code>,
size and style options).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A pair <code class="docutils literal notranslate"><span class="pre">(artists,</span> <span class="pre">ax)</span></code> where <code class="docutils literal notranslate"><span class="pre">artists</span></code> is the object returned by
<code class="docutils literal notranslate"><span class="pre">networkx.draw_networkx</span></code> (backend-dependent; often <code class="docutils literal notranslate"><span class="pre">None</span></code>) and
<code class="docutils literal notranslate"><span class="pre">ax</span></code> is the axes used for drawing.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyOCN.plot_ocn_raster">
<span class="sig-prename descclassname"><span class="pre">PyOCN.</span></span><span class="sig-name descname"><span class="pre">plot_ocn_raster</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ocn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attribute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'energy'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/plotting.html#plot_ocn_raster"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyOCN.plot_ocn_raster" title="Link to this definition"></a></dt>
<dd><p>Plot a raster image of grid cell energies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ocn</strong> (<a class="reference internal" href="#id6" title="PyOCN.OCN"><em>OCN</em></a>) – The OCN instance to plot.</p></li>
<li><p><strong>attribute</strong> (<em>str</em><em>, </em><em>default 'energy'</em>) – The node attribute to visualize (e.g., ‘energy’, ‘drained_area’).</p></li>
<li><p><strong>ax</strong> (<em>matplotlib.axes.Axes</em><em>, </em><em>optional</em>) – Target axes. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, a new figure and axes are created.</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments forwarded to <code class="docutils literal notranslate"><span class="pre">imshow</span></code> (e.g.,
<code class="docutils literal notranslate"><span class="pre">cmap</span></code>, interpolation options, and normalization).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The axes containing the rendered image.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>matplotlib.axes.Axes</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyOCN.plot_positional_digraph">
<span class="sig-prename descclassname"><span class="pre">PyOCN.</span></span><span class="sig-name descname"><span class="pre">plot_positional_digraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/plotting.html#plot_positional_digraph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyOCN.plot_positional_digraph" title="Link to this definition"></a></dt>
<dd><p>Plot a DAG with node positions taken from their <code class="docutils literal notranslate"><span class="pre">pos</span></code> attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dag</strong> (<em>nx.DiGraph</em>) – Graph whose nodes have <code class="docutils literal notranslate"><span class="pre">pos=(row,</span> <span class="pre">col)</span></code>.</p></li>
<li><p><strong>ax</strong> (<em>matplotlib.axes.Axes</em><em>, </em><em>optional</em>) – Target axes. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, a new figure and axes are created.</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments forwarded to
<code class="xref py py-func docutils literal notranslate"><span class="pre">networkx.draw_networkx()</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A pair <code class="docutils literal notranslate"><span class="pre">(artists,</span> <span class="pre">ax)</span></code> where <code class="docutils literal notranslate"><span class="pre">artists</span></code> is the object returned by
<code class="docutils literal notranslate"><span class="pre">networkx.draw_networkx</span></code> (often <code class="docutils literal notranslate"><span class="pre">None</span></code>) and <code class="docutils literal notranslate"><span class="pre">ax</span></code> is the axes
used for drawing.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyOCN.simulated_annealing_schedule">
<span class="sig-prename descclassname"><span class="pre">PyOCN.</span></span><span class="sig-name descname"><span class="pre">simulated_annealing_schedule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">E0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant_phase</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iterations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cooling_rate</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/utils.html#simulated_annealing_schedule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyOCN.simulated_annealing_schedule" title="Link to this definition"></a></dt>
<dd><p>Create a simulated-annealing cooling schedule for OCN optimization.</p>
<blockquote>
<div><p>This returns a callable <code class="docutils literal notranslate"><span class="pre">schedule(i)</span></code> that returns the temperature at
iteration <code class="docutils literal notranslate"><span class="pre">i</span></code>. The schedule consists of a constant-temperature phase
followed by an exponentially decaying phase.</p>
<dl class="simple">
<dt>dims<span class="classifier">tuple[int, int]</span></dt><dd><p>The dimensions of the grid as (rows, cols).</p>
</dd>
<dt>E0<span class="classifier">float</span></dt><dd><p>Initial energy value.</p>
</dd>
<dt>constant_phase<span class="classifier">float</span></dt><dd><p>Fraction of iterations (<code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">fraction</span> <span class="pre">&lt;=</span> <span class="pre">1</span></code>) during which the
temperature remains constant at <code class="docutils literal notranslate"><span class="pre">Energy[0]</span></code>.</p>
</dd>
<dt>n_iterations<span class="classifier">int</span></dt><dd><p>Total number of optimization iterations.</p>
</dd>
<dt>cooling_rate<span class="classifier">float</span></dt><dd><p>Positive decay rate controlling the exponential temperature decrease
after the constant phase.</p>
</dd>
</dl>
<dl class="simple">
<dt>Callable[[int], float] | numpy.ndarray</dt><dd><p>A function mapping an iteration index <code class="docutils literal notranslate"><span class="pre">i</span></code> to a temperature value. If
vectorized evaluation is used, may return a NumPy array of temperatures.</p>
</dd>
</dl>
<p>The exponential phase follows the form</p>
<div class="math notranslate nohighlight">
\[T_i = E_0 \exp\left(-\]</div>
</div></blockquote>
<p>rac{      ext{cooling_rate},(i - n_0)}{N}
ight),</p>
<blockquote>
<div><p>where <code class="docutils literal notranslate"><span class="pre">E0</span></code> is the initial energy, <code class="docutils literal notranslate"><span class="pre">n0</span></code> is the number of iterations in
the constant phase, and <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">rows</span> <span class="pre">*</span> <span class="pre">cols</span></code>.</p>
</div></blockquote>
<dl class="field-list simple">
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="PyOCN.unwrap_digraph">
<span class="sig-prename descclassname"><span class="pre">PyOCN.</span></span><span class="sig-name descname"><span class="pre">unwrap_digraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/utils.html#unwrap_digraph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#PyOCN.unwrap_digraph" title="Link to this definition"></a></dt>
<dd><p>“unwrap” gridcell coordinate attributes in a directed acyclic graph to place connected
nodes adjacent to each other, removing periodic boundary conditions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dag</strong> (<em>nx.DiGraph</em>) – The input directed acyclic graph with periodic boundary conditions.
Each node must have a ‘pos’ attribute indicating its (row, col) position.</p></li>
<li><p><strong>dims</strong> (<em>tuple</em><em>[</em><em>int</em><em>, </em><em>int</em><em>]</em>) – The dimensions of the grid as (rows, cols). Both must be positive integers.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new directed acyclic graph with unwrapped grid coordinates. May not be
consistent with a grid structure.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>nx.DiGraph</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If any node in the input graph lacks a ‘pos’ attribute or if the
    dimensions are not positive integers.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The function assumes that the input graph is a valid DAG and that the
‘pos’ attributes are correctly assigned. The output graph will no longer
span a toroidal topology and will no longer cover a dense grid of nodes.</p>
</dd></dl>

<section id="ocn-class">
<h2>OCN Class<a class="headerlink" href="#ocn-class" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="id6">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">PyOCN.</span></span><span class="sig-name descname"><span class="pre">OCN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id6" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The main class for interacting with Optimized Channel Networks.</p>
<p>Use <a class="reference internal" href="#id27" title="PyOCN.OCN.from_net_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OCN.from_net_type()</span></code></a> or <a class="reference internal" href="#id26" title="PyOCN.OCN.from_digraph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OCN.from_digraph()</span></code></a> to construct an
instance.</p>
<section id="id7">
<h3>Constructor Methods<a class="headerlink" href="#id7" title="Link to this heading"></a></h3>
<dl class="simple">
<dt><a class="reference internal" href="#id27" title="PyOCN.OCN.from_net_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_net_type()</span></code></a></dt><dd><p>Create an OCN from a predefined network type and dimensions.</p>
</dd>
<dt><a class="reference internal" href="#id26" title="PyOCN.OCN.from_digraph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_digraph()</span></code></a></dt><dd><p>Create an OCN from an existing NetworkX DiGraph.</p>
</dd>
</dl>
</section>
<section id="id8">
<h3>Export Methods<a class="headerlink" href="#id8" title="Link to this heading"></a></h3>
<dl class="simple">
<dt><a class="reference internal" href="#id33" title="PyOCN.OCN.to_digraph"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_digraph()</span></code></a></dt><dd><p>Export the current grid to a NetworkX DiGraph.</p>
</dd>
<dt><a class="reference internal" href="#id35" title="PyOCN.OCN.to_numpy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_numpy()</span></code></a></dt><dd><p>Export raster arrays (energy, drained area, watershed_id) as numpy arrays.</p>
</dd>
<dt><a class="reference internal" href="#id36" title="PyOCN.OCN.to_xarray"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_xarray()</span></code></a></dt><dd><p>Export raster arrays as an xarray Dataset (requires xarray).</p>
</dd>
<dt><a class="reference internal" href="#id34" title="PyOCN.OCN.to_gtiff"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_gtiff()</span></code></a></dt><dd><p>Export raster arrays to a GeoTIFF file (requires rasterio).</p>
</dd>
<dt><a class="reference internal" href="#id21" title="PyOCN.OCN.copy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code></a></dt><dd><p>Create a deep copy of the OCN.</p>
</dd>
</dl>
</section>
<section id="id9">
<h3>Optimization Methods<a class="headerlink" href="#id9" title="Link to this heading"></a></h3>
<dl class="simple">
<dt><code class="xref py py-meth docutils literal notranslate"><span class="pre">single_erosion_event()</span></code></dt><dd><p>Perform a single erosion event at a given temperature.</p>
</dd>
<dt><a class="reference internal" href="#id24" title="PyOCN.OCN.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a></dt><dd><p>Optimize the network using the simulated annealing method from Carraro et al (2020).</p>
</dd>
<dt><a class="reference internal" href="#id25" title="PyOCN.OCN.fit_custom_cooling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit_custom_cooling()</span></code></a></dt><dd><p>Optimize the network using a custom cooling function.</p>
</dd>
</dl>
</section>
<section id="id10">
<h3>Other methods<a class="headerlink" href="#id10" title="Link to this heading"></a></h3>
<dl class="simple">
<dt><a class="reference internal" href="#id20" title="PyOCN.OCN.compute_energy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compute_energy()</span></code></a></dt><dd><p>Compute the current energy of the network.</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="id11">
<span class="sig-name descname"><span class="pre">energy</span></span><a class="headerlink" href="#id11" title="Link to this definition"></a></dt>
<dd><p>Current energy of the network (read-only property).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id12">
<span class="sig-name descname"><span class="pre">dims</span></span><a class="headerlink" href="#id12" title="Link to this definition"></a></dt>
<dd><p>Grid dimensions (rows, cols) of the FlowGrid (read-only property).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple[int, int]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id13">
<span class="sig-name descname"><span class="pre">resolution</span></span><a class="headerlink" href="#id13" title="Link to this definition"></a></dt>
<dd><p>The side length of each grid cell (read-only property).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id14">
<span class="sig-name descname"><span class="pre">nroots</span></span><a class="headerlink" href="#id14" title="Link to this definition"></a></dt>
<dd><p>Number of root nodes in the current OCN grid (read-only property).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id15">
<span class="sig-name descname"><span class="pre">gamma</span></span><a class="headerlink" href="#id15" title="Link to this definition"></a></dt>
<dd><p>Exponent in the energy model.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id16">
<span class="sig-name descname"><span class="pre">master_seed</span></span><a class="headerlink" href="#id16" title="Link to this definition"></a></dt>
<dd><p>The seed used to initialize the internal RNG.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id17">
<span class="sig-name descname"><span class="pre">verbosity</span></span><a class="headerlink" href="#id17" title="Link to this definition"></a></dt>
<dd><p>Verbosity level for underlying library output (0-2).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id18">
<span class="sig-name descname"><span class="pre">wrap</span></span><a class="headerlink" href="#id18" title="Link to this definition"></a></dt>
<dd><p>If true, enables periodic boundary conditions on the FlowGrid (read-only property).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id19">
<span class="sig-name descname"><span class="pre">history</span></span><a class="headerlink" href="#id19" title="Link to this definition"></a></dt>
<dd><p>numpy array of shape (n_iterations, 3) recording the iteration index, energy, and temperature at each iteration during optimization.
Updated each time an optimization method is called.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Examples</p>
<p>The following is a simple example of creating, optimizing, and plotting
an OCN using PyOCN and Matplotlib. More examples are available in the
<cite>demo.ipynb</cite> notebook in the repository (<a class="reference external" href="https://github.com/alextsfox/PyOCN">https://github.com/alextsfox/PyOCN</a>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Fit an OCN from a &quot;Hip-roof&quot; initial network shape and periodic boundary conditions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">mpl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">PyOCN</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">po</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ocn</span> <span class="o">=</span> <span class="n">po</span><span class="o">.</span><span class="n">OCN</span><span class="o">.</span><span class="n">from_net_type</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">8472</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ocn</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">po</span><span class="o">.</span><span class="n">plot_ocn_raster</span><span class="p">(</span><span class="n">ocn</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">PowerNorm</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">attribute</span><span class="o">=</span><span class="s1">&#39;drained_area&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="id20">
<span class="sig-name descname"><span class="pre">compute_energy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.compute_energy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id20" title="Link to this definition"></a></dt>
<dd><p>Compute the current energy of the network.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The computed energy value.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This constructs a temporary <code class="docutils literal notranslate"><span class="pre">DiGraph</span></code> view to aggregate node
energies from drained areas using the exponent <code class="docutils literal notranslate"><span class="pre">gamma</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id21">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id21" title="Link to this definition"></a></dt>
<dd><p>Create a deep copy of the OCN, including the underlying FlowGrid_C.
Also copies the current RNG state. The new copy and the original
will be independent from each other and behave identically statistically.</p>
<dl class="field-list simple">
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="id22">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dims</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#id22" title="Link to this definition"></a></dt>
<dd><p>Grid dimensions of the FlowGrid (read-only).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(rows,</span> <span class="pre">cols)</span></code>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[int, int]</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="id23">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">energy</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#id23" title="Link to this definition"></a></dt>
<dd><p>Energy of the current OCN.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Current energy.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id24">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cooling_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant_phase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_reports</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iterations_per_loop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unwrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id24" title="Link to this definition"></a></dt>
<dd><p>Convenience function to optimize the OCN using the simulated annealing algorithm from Carraro et al (2020).
For finer control over the optimization process, use <a class="reference internal" href="#id25" title="PyOCN.OCN.fit_custom_cooling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit_custom_cooling()</span></code></a> or use <code class="xref py py-meth docutils literal notranslate"><span class="pre">single_erosion_event()</span></code> in a loop.</p>
<p>This performs <code class="docutils literal notranslate"><span class="pre">n_iterations</span></code> erosion events, accepting or rejecting
proposals according to a temperature schedule defined by the annealing algorithm.
A proposal consists of changing the outflow direction of a randomly selected vertex.
The new outflow direction is chosen uniformly from the valid neighbors.
A proposal is valid if it maintains a well-formed graph structure.</p>
<p>The <a class="reference internal" href="#id28" title="PyOCN.OCN.history"><code class="xref py py-attr docutils literal notranslate"><span class="pre">history</span></code></a> attribute is updated in-place after optimization finishes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ocn</strong> (<a class="reference internal" href="#id6" title="PyOCN.OCN"><em>OCN</em></a>) – The OCN instance to optimize.</p></li>
<li><p><strong>cooling_rate</strong> (<em>float</em><em>, </em><em>default 1.0</em>) – Cooling rate parameter in the annealing algorithm. Typical range is 0.5-1.5.
Higher values result in faster cooling and a greedier search.
Lower values result in slower cooling and more thorough exploration of the solution space, but slower convergence and lower stability.</p></li>
<li><p><strong>constant_phase</strong> (<em>float</em><em>, </em><em>default 0.0</em>) – Amount of time to hold temeprature constant at the start of the optimization.
This is a fraction of n_iterations, and must be in the range [0, 1].
A value of 0.0 (default) means the temperature starts cooling immediately
from the initial temperature. A value of 1.0 means the temperature is held
constant for the entire optimization.</p></li>
<li><p><strong>n_iterations</strong> (<em>int</em><em>, </em><em>optional</em>) – Total number of iterations. Defaults to <code class="docutils literal notranslate"><span class="pre">40</span> <span class="pre">*</span> <span class="pre">rows</span> <span class="pre">*</span> <span class="pre">cols</span></code>.
Always at least <code class="docutils literal notranslate"><span class="pre">energy_reports</span> <span class="pre">*</span> <span class="pre">10</span></code> (this should only matter for
extremely small grids, where <code class="docutils literal notranslate"><span class="pre">rows</span> <span class="pre">*</span> <span class="pre">cols</span> <span class="pre">&lt;</span> <span class="pre">256</span></code>).</p></li>
<li><p><strong>pbar</strong> (<em>bool</em><em>, </em><em>default True</em>) – Whether to display a progress bar.</p></li>
<li><p><strong>array_reports</strong> (<em>int</em><em>, </em><em>default 0</em>) – <p>Number of timepoints (approximately) at which to save the state of the FlowGrid.
If 0 (default), returns None. If &gt;0, returns an xarray.Dataset
containing the state of the FlowGrid at approximately evenly spaced intervals
throughout the optimization, including the initial and final states. Requires xarray to be installed.</p>
<dl class="simple">
<dt>The returned xarray.Dataset will have coordinates:</dt><dd><ul>
<li><p><cite>y</cite> (float) representing the northing coordinate of each row</p></li>
<li><p><cite>x</cite> (float) representing the easting coordinate of each column</p></li>
<li><p><cite>iteration</cite> (int) representing the iteration index at which the data was recorded</p></li>
</ul>
</dd>
<dt>data variables:</dt><dd><ul>
<li><p><cite>energy_rasters</cite> (np.float64) representing energy at each grid cell</p></li>
<li><p><cite>area_rasters</cite> (np.float64) representing drained area at each grid cell</p></li>
<li><p><cite>watershed_id</cite> (np.int32). NA value is -9999. Roots have value -1. Represents the watershed membership ID for each grid cell.</p></li>
</ul>
</dd>
</dl>
<p>The coordiante (0, 0) is the top-left corner of the grid.</p>
<dl>
<dt>If the OCN has a periodic boundary condition, the following changes apply:</dt><dd><ul>
<li><p>The (0,0) coordinate will be set to the position of the “main” root node, defined as</p></li>
</ul>
<p>the root node with the smallest row*cols + col value
- The rasters will be unwrapped to a non-periodic representation, which may result in larger rasters.
- The size of the final rasters are the maximum extent of the unwrapped grid, taken across all iterations.</p>
</dd>
</dl>
<p>Generating reports requires additional memory and computation time.</p>
</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – If provided, optimization will stop early if the relative change
in energy between reports is less than <cite>tol</cite>. Must be positive.
If None (default), no early stopping is performed.
Recommended values are in the range 1e-4 to 1e-6.</p></li>
<li><p><strong>max_iterations_per_loop</strong> (<em>int</em><em>, </em><em>optional</em>) – If provided, the number of iterations steps to perform in each “chunk”
of optimization. Energy and output arrays can be reported no more often
than this. Recommended values are 1_000-1_000_000. Default is 10_000.</p></li>
<li><p><strong>unwrap</strong> (<em>bool</em><em>, </em><em>default True</em>) – If True and the current OCN has periodic boundaries, the
resulting rasters will be transformed so connected grid cells
are adjacent in the output. This will result in a larger raster
with some nan values. If False or the current OCN does not have
periodic boundaries, then no transformation is applied and the
resulting raster will have the same dimensions as the current OCN grid.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>xr.Dataset | None</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – </p>
</dd>
<dt class="field-even">Warns<span class="colon">:</span></dt>
<dd class="field-even"><ul>
<li><p><strong>UserWarning</strong></p></li>
<li><p><strong>Optimization Algorithm</strong></p></li>
<li><p><strong>———————-</strong></p></li>
<li><p><strong>At iteration ``i``, the outflow of a random grid cell if proposed to be rerouted.</strong></p></li>
<li><p><strong>The proposal is accepted with the probability</strong></p></li>
<li><p><strong>.. math::</strong> – P(  ext{accept}) = e^{-Delta E / T},</p></li>
<li><p><strong>where :math:`Delta E` is the change in energy the change would cause</strong></p></li>
<li><p><strong>and :math:`T` is the temperature of the network.</strong></p></li>
<li><p><strong>The total energy of the system is computed from the drained areas of each grid cell :math:`k` as</strong></p></li>
<li><p><strong>.. math::</strong> – E = sum_k A_k^gamma</p></li>
<li><p><strong>The temperature of the network is governed by a cooling schedule, which is a function of iteration index.</strong></p></li>
<li><p><strong>Note that when :math:`Delta E &lt; 0`, the move is always accepted.</strong></p></li>
<li><p><strong>Simulated Annealing Schedule</strong></p></li>
<li><p><strong>—————————-</strong></p></li>
<li><p><strong>The cooling schedule used by this method is a piecewise function of iteration index</strong></p></li>
<li><p><strong>.. math::</strong> –</p>
<dl class="simple">
<dt>T(i) = egin{cases}</dt><dd><p>E_0 &amp; i &lt; C N E_0 cdot e^{;i - C N} &amp; i ge C N</p>
</dd>
</dl>
<p>end{cases}</p>
</li>
<li><p><strong>where :math:`E_0` is the initial energy, :math:`N` is the total number</strong></p></li>
<li><p><strong>of iterations, and :math:`C` is ``constant_phase``. Decreasing-energy</strong></p></li>
<li><p><strong>moves (:math:`Delta E &lt; 0`) are always accepted.</strong></p></li>
<li><p><strong>Alternative cooling schedules can be implemented using :meth:`fit_custom_cooling`.</strong></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id25">
<span class="sig-name descname"><span class="pre">fit_custom_cooling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cooling_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iteration_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_reports</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iterations_per_loop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unwrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.fit_custom_cooling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id25" title="Link to this definition"></a></dt>
<dd><p>Optimize the OCN using the a custom cooling schedule. This allows for
multi-stage optimizations or other custom cooling schedules not covered by the default simulated annealing schedule
from Carraro et al (2020).</p>
<p>See <a class="reference internal" href="#id24" title="PyOCN.OCN.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> for additional details on the optimization algorithm and parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ocn</strong> (<a class="reference internal" href="#id6" title="PyOCN.OCN"><em>OCN</em></a>) – The OCN instance to optimize.</p></li>
<li><p><strong>cooling_func</strong> (<em>Callable</em><em>[</em><em>[</em><em>np.ndarray</em><em>]</em><em>, </em><em>np.ndarray</em><em>]</em>) – A function that takes an array of iteration indices and returns an array of temperatures.
This function defines the cooling schedule for the optimization. Note that the function
should return temperatures that are appropriate for the current energy of the OCN.</p></li>
<li><p><strong>n_iterations</strong> (<em>int</em><em>, </em><em>optional</em>)</p></li>
<li><p><strong>iteration_start</strong> (<em>int</em><em>, </em><em>default 0</em>) – The starting iteration index. This is useful for continuing an optimization
from a previous run. Must be a non-negative integer. If provided, <code class="docutils literal notranslate"><span class="pre">n_iterations</span></code>
is the number of additional iterations to perform. The iteration number passed to
<code class="docutils literal notranslate"><span class="pre">cooling_func</span></code> will be <code class="docutils literal notranslate"><span class="pre">iteration_start</span> <span class="pre">+</span> <span class="pre">i</span></code> where <code class="docutils literal notranslate"><span class="pre">i</span></code> is the current iteration index
in the range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">n_iterations-1]</span></code>.</p></li>
<li><p><strong>pbar</strong> (<em>bool</em><em>, </em><em>default True</em>)</p></li>
<li><p><strong>array_reports</strong> (<em>int</em><em>, </em><em>default 0</em>)</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>)</p></li>
<li><p><strong>max_iterations_per_loop</strong> (<em>int</em><em>, </em><em>optional</em>)</p></li>
<li><p><strong>unwrap</strong> (<em>bool</em><em>, </em><em>default True</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>xr.Dataset | None</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – </p>
</dd>
<dt class="field-even">Warns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>UserWarning</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id26">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_digraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.from_digraph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id26" title="Link to this definition"></a></dt>
<dd><p>Create an <a class="reference internal" href="#id6" title="PyOCN.OCN"><code class="xref py py-class docutils literal notranslate"><span class="pre">OCN</span></code></a> from an existing NetworkX <code class="docutils literal notranslate"><span class="pre">DiGraph</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dag</strong> (<em>nx.DiGraph</em>) – Directed acyclic graph (DAG) representing the stream network.</p></li>
<li><p><strong>resolution</strong> (<em>int</em><em>, </em><em>optional</em>) – The side length of each grid cell.</p></li>
<li><p><strong>gamma</strong> (<em>float</em><em>, </em><em>default 0.5</em>) – Exponent in the energy model.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em> | </em><em>numpy.random.Generator</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Seed or generator for RNG seeding.</p></li>
<li><p><strong>verbosity</strong> (<em>int</em><em>, </em><em>default 0</em>) – Verbosity level (0-2) for underlying library output.</p></li>
<li><p><strong>wrap</strong> (<em>bool</em><em>, </em><em>default False</em>) – If true, allows wrapping around the edges of the grid (toroidal). If false, no wrapping is applied.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A newly constructed instance encapsulating the provided graph.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#id6" title="PyOCN.OCN">OCN</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The input graph must satisfy all of the following:</p>
<ul class="simple">
<li><p>It is a directed acyclic graph (DAG).</p></li>
<li><p>Each node has attribute <code class="docutils literal notranslate"><span class="pre">pos=(row:int,</span> <span class="pre">col:int)</span></code> specifying its
grid position with non-negative coordinates. Any other attributes
are ignored.</p></li>
<li><p>The graph can be partitioned into one or more spanning trees over
a dense grid of shape <code class="docutils literal notranslate"><span class="pre">(m,</span> <span class="pre">n)</span></code>: each grid cell corresponds to
exactly one node; each non-root node has <code class="docutils literal notranslate"><span class="pre">out_degree</span> <span class="pre">==</span> <span class="pre">1</span></code>;
the roots have <code class="docutils literal notranslate"><span class="pre">out_degree</span> <span class="pre">==</span> <span class="pre">0</span></code>.</p></li>
<li><p>Edges connect only to one of the 8 neighbors (cardinal or diagonal),
i.e., no jumps over rows or columns. If <code class="docutils literal notranslate"><span class="pre">wrap=True</span></code>, edges may
connect across the grid boundaries (i.e. row 0 can connect to row m-1 and col 0 can connect to col n-1).</p></li>
<li><p>Edges do not cross in the row-column plane.</p></li>
<li><p>Both <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code> are positive integers, and there are at least four
vertices.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># creating a &quot;zig-zag&quot; network</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># O O O O</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># |/|/|/|</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># O O O X</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">PyOCN</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">po</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">mpl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">dag</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">4</span><span class="p">,</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">:</span> <span class="n">dag</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ocn</span> <span class="o">=</span> <span class="n">OCN</span><span class="o">.</span><span class="n">from_digraph</span><span class="p">(</span><span class="n">dag</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">8472</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ocn</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">po</span><span class="o">.</span><span class="n">plot_ocn_raster</span><span class="p">(</span><span class="n">ocn</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">PowerNorm</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">attribute</span><span class="o">=</span><span class="s1">&#39;drained_area&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id27">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_net_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbosity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.from_net_type"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id27" title="Link to this definition"></a></dt>
<dd><p>Create an <a class="reference internal" href="#id6" title="PyOCN.OCN"><code class="xref py py-class docutils literal notranslate"><span class="pre">OCN</span></code></a> from a predefined network type and dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net_type</strong> (<em>str</em>) – Predefined network type to instantiate from. Valid types are “H”, “I”, “E”, and “V”. See
<code class="xref py py-func docutils literal notranslate"><span class="pre">net_type_to_dag()</span></code> for more information.</p></li>
<li><p><strong>dims</strong> (<em>tuple</em><em>[</em><em>int</em><em>, </em><em>int</em><em>]</em>) – Grid dimensions (rows, cols). Both must be positive even integers.</p></li>
<li><p><strong>resolution</strong> (<em>int</em><em>, </em><em>optional</em>) – The side length of each grid cell.</p></li>
<li><p><strong>gamma</strong> (<em>float</em><em>, </em><em>default 0.5</em>) – Exponent in the energy model.</p></li>
<li><p><strong>random_state</strong> (<em>int</em><em> | </em><em>numpy.random.Generator</em><em> | </em><em>None</em><em>, </em><em>optional</em>) – Seed or generator for RNG seeding.</p></li>
<li><p><strong>verbosity</strong> (<em>int</em><em>, </em><em>default 0</em>) – Verbosity level (0-2) for underlying library output.</p></li>
<li><p><strong>wrap</strong> (<em>bool</em><em>, </em><em>default False</em>) – If true, allows wrapping around the edges of the grid (toroidal). If false, no wrapping is applied.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A newly constructed instance initialized from the specified
network type and dimensions.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#id6" title="PyOCN.OCN">OCN</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="id28">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">history</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span></em><a class="headerlink" href="#id28" title="Link to this definition"></a></dt>
<dd><p>numpy array of shape (n_iterations, 3) recording the iteration index, energy, and temperature at each iteration during optimization.
If multiple fit calls are made, history is appended to this array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The optimization history.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="id29">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nroots</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#id29" title="Link to this definition"></a></dt>
<dd><p>Number of root nodes in the current OCN grid (read-only).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Current number of root nodes.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="id30">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">resolution</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#id30" title="Link to this definition"></a></dt>
<dd><p>Resolution of the current OCN grid in m (read-only).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Current resolution.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="id31">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rng</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#id31" title="Link to this definition"></a></dt>
<dd><p>returns: the current random state of the internal RNG as four 32-bit unsigned integers.
:rtype: tuple[int, int, int, int]</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id32">
<span class="sig-name descname"><span class="pre">single_iteration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">temperature</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_report</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unwrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.single_iteration"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id32" title="Link to this definition"></a></dt>
<dd><p>Perform a single iteration of the optimization algorithm at a given temperature. Updates the internal history attribute.
See <a class="reference internal" href="#id24" title="PyOCN.OCN.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> for details on the algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>temperature</strong> (<em>float</em>) – Temperature parameter governing acceptance probability. Typical
range is a fraction of ocn.energy.</p></li>
<li><p><strong>array_report</strong> (<em>bool</em><em>, </em><em>default False</em>) – If True (default), the returned result will be an xarray.Dataset.
See <a class="reference internal" href="#id24" title="PyOCN.OCN.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code></a> for details. The returned object will have an iteration dimension of size 1.
Requires xarray to be installed.</p></li>
<li><p><strong>unwrap</strong> (<em>bool</em><em>, </em><em>default True</em>) – If True and the current OCN has periodic boundaries, the
resulting rasters will be transformed so connected grid cells
are adjacent in the output. This will result in a larger raster
with some nan values. If False or the current OCN does not have
periodic boundaries, then no transformation is applied and the
resulting raster will have the same dimensions as the current OCN grid.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>LibOCNError</strong> – If the underlying C routine reports an error status.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id33">
<span class="sig-name descname"><span class="pre">to_digraph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.to_digraph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id33" title="Link to this definition"></a></dt>
<dd><p>Create a NetworkX <code class="docutils literal notranslate"><span class="pre">DiGraph</span></code> view of the current grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>A DAG with the following node attributes per node:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pos</span></code>: <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> grid position</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">drained_area</span></code>: drained area value</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">energy</span></code>: cumulative energy at the node</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">watershed_id</span></code>: integer watershed ID (roots have watershed id = -1)</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>nx.DiGraph</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id34">
<span class="sig-name descname"><span class="pre">to_gtiff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">west</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">north</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unwrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.to_gtiff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id34" title="Link to this definition"></a></dt>
<dd><p>Export a raster of the current FlowGrid to a GeoTIFF file
using rasterio. The resulting raster has 3 bands: <cite>energy</cite>, <cite>drained_area</cite>, and <cite>watershed_id</cite>.
The <cite>watershed_id</cite> band contains integer watershed IDs assigned to each node,
with root nodes assigned a value of -1. NA values are either np.nan (for energy and drained_area)
or -9999 (for watershed_id).</p>
<p>N.B. This uses the <a class="reference internal" href="#id30" title="PyOCN.OCN.resolution"><code class="xref py py-attr docutils literal notranslate"><span class="pre">resolution</span></code></a> attribute to set pixel size in the raster.
This function does not check for unit compatibility, so it is up to the user
to ensure the resolution and CRS units match. By default,
the resolution is set to 1.0. Using a CRS with degree units in this case
would result in a pixel size of 1 degree, which is likely not what you want.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>west</strong> (<em>float</em>) – The western border of the raster in crs units, corresponding
to column 0.</p></li>
<li><p><strong>north</strong> (<em>float</em>) – The northern border of the raster in crs units, corresponding
to row 0.</p></li>
<li><p><strong>crs</strong> (<em>Any</em>) – The crs for the resulting gtiff, passed to <cite>rasterio.open</cite></p></li>
<li><p><strong>path</strong> (<em>str</em><em> or </em><em>Pathlike</em>) – The output path for the resulting gtiff file.</p></li>
<li><p><strong>unwrap</strong> (<em>bool</em><em>, </em><em>default True</em>) – If True and the current OCN has periodic boundaries, the
resulting raster will be transformed so connected grid cells
are adjacent in the raster. This will result in a larger raster
with some nan values. If False or the current OCN does not have
periodic boundaries, then no transformation is applied and the
raster will have the same dimensions as the current OCN grid.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id35">
<span class="sig-name descname"><span class="pre">to_numpy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unwrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.to_numpy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id35" title="Link to this definition"></a></dt>
<dd><p>Export the current FlowGrid to a numpy array with shape (2, rows, cols).
Has two channels: 0=energy, 1=drained_area.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>unwrap</strong> (<em>bool</em><em>, </em><em>default True</em>) – If True and the current OCN has periodic boundaries, the
resulting array will be transformed so connected grid cells
are adjacent in the array. This will result in a larger array
with some nan values. If False or the current OCN does not have
periodic boundaries, then no transformation is applied and the
resulting array will have the same dimensions as the current OCN grid.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id36">
<span class="sig-name descname"><span class="pre">to_xarray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unwrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/ocn.html#OCN.to_xarray"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id36" title="Link to this definition"></a></dt>
<dd><p>Export the current FlowGrid to an xarray Dataset</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>unwrap</strong> (<em>bool</em><em>, </em><em>default True</em>) – <p>If True and the current OCN has periodic boundaries, the
resulting rasters will be transformed so connected grid cells
are adjacent in the output. This will result in a larger raster
with some nan values. If False or the current OCN does not have
periodic boundaries, then no transformation is applied and the
resulting raster will have the same dimensions as the current OCN grid.</p>
<p>When unwrapping, the (0,0) coordinate
will be set to the position of the “main” root node, defined as
the root node with the smallest row*cols + col value. Otherwise,
(0,0) will be the top-left corner of the grid.</p>
</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul>
<li><p><em>xr.Dataset</em> –</p>
<dl class="simple">
<dt>an xarray Dataset with data variables:</dt><dd><ul class="simple">
<li><p><cite>energy_rasters</cite> (np.float64) representing energy at each grid cell</p></li>
<li><p><cite>area_rasters</cite> (np.float64) representing drained area at each grid cell</p></li>
<li><p><cite>watershed_id</cite> (np.int32). NA value is -9999. Roots have value -1. Represents the watershed membership ID for each grid cell.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p><em>and coordinates</em> –</p>
<ul class="simple">
<li><p><cite>y</cite> (float) representing the northing coordinate of each row.</p></li>
<li><p><cite>x</cite> (float) representing the easting coordinate of each column.</p></li>
</ul>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>xr.Dataset</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="id37">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">wrap</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#id37" title="Link to this definition"></a></dt>
<dd><p>Whether the grid allows wrapping around the edges (toroidal).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Current wrap setting.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

</section>
<dl class="field-list simple">
</dl>
</dd></dl>

</section>
<section id="plotting-functions">
<h2>Plotting Functions<a class="headerlink" href="#plotting-functions" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="id38">
<span class="sig-prename descclassname"><span class="pre">PyOCN.</span></span><span class="sig-name descname"><span class="pre">plot_ocn_raster</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ocn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attribute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'energy'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/plotting.html#plot_ocn_raster"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id38" title="Link to this definition"></a></dt>
<dd><p>Plot a raster image of grid cell energies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ocn</strong> (<a class="reference internal" href="#id6" title="PyOCN.OCN"><em>OCN</em></a>) – The OCN instance to plot.</p></li>
<li><p><strong>attribute</strong> (<em>str</em><em>, </em><em>default 'energy'</em>) – The node attribute to visualize (e.g., ‘energy’, ‘drained_area’).</p></li>
<li><p><strong>ax</strong> (<em>matplotlib.axes.Axes</em><em>, </em><em>optional</em>) – Target axes. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, a new figure and axes are created.</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments forwarded to <code class="docutils literal notranslate"><span class="pre">imshow</span></code> (e.g.,
<code class="docutils literal notranslate"><span class="pre">cmap</span></code>, interpolation options, and normalization).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The axes containing the rendered image.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>matplotlib.axes.Axes</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id39">
<span class="sig-prename descclassname"><span class="pre">PyOCN.</span></span><span class="sig-name descname"><span class="pre">plot_ocn_as_dag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ocn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attribute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/plotting.html#plot_ocn_as_dag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id39" title="Link to this definition"></a></dt>
<dd><p>Plot the OCN as a DAG using NetworkX.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ocn</strong> (<a class="reference internal" href="#id6" title="PyOCN.OCN"><em>OCN</em></a>) – The OCN instance to plot.</p></li>
<li><p><strong>attribute</strong> (<em>str</em><em>, </em><em>optional</em>) – Node attribute name for coloring (e.g., <code class="docutils literal notranslate"><span class="pre">'drained_area'</span></code> or
<code class="docutils literal notranslate"><span class="pre">'energy'</span></code>). If omitted, a uniform color is used.</p></li>
<li><p><strong>ax</strong> (<em>matplotlib.axes.Axes</em><em>, </em><em>optional</em>) – Target axes. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, a new figure and axes are created.</p></li>
<li><p><strong>norm</strong> (<em>matplotlib.colors.Normalize</em><em>, </em><em>optional</em>) – Normalization to apply to node colors when <code class="docutils literal notranslate"><span class="pre">attribute</span></code> is provided.
If specified, any <code class="docutils literal notranslate"><span class="pre">vmin</span></code>/<code class="docutils literal notranslate"><span class="pre">vmax</span></code> passed in <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> are ignored.</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments forwarded to
<code class="xref py py-func docutils literal notranslate"><span class="pre">networkx.draw_networkx()</span></code> (e.g., <code class="docutils literal notranslate"><span class="pre">cmap</span></code>, <code class="docutils literal notranslate"><span class="pre">vmin</span></code>, <code class="docutils literal notranslate"><span class="pre">vmax</span></code>,
size and style options).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A pair <code class="docutils literal notranslate"><span class="pre">(artists,</span> <span class="pre">ax)</span></code> where <code class="docutils literal notranslate"><span class="pre">artists</span></code> is the object returned by
<code class="docutils literal notranslate"><span class="pre">networkx.draw_networkx</span></code> (backend-dependent; often <code class="docutils literal notranslate"><span class="pre">None</span></code>) and
<code class="docutils literal notranslate"><span class="pre">ax</span></code> is the axes used for drawing.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id40">
<span class="sig-prename descclassname"><span class="pre">PyOCN.</span></span><span class="sig-name descname"><span class="pre">plot_positional_digraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyOCN/plotting.html#plot_positional_digraph"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#id40" title="Link to this definition"></a></dt>
<dd><p>Plot a DAG with node positions taken from their <code class="docutils literal notranslate"><span class="pre">pos</span></code> attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dag</strong> (<em>nx.DiGraph</em>) – Graph whose nodes have <code class="docutils literal notranslate"><span class="pre">pos=(row,</span> <span class="pre">col)</span></code>.</p></li>
<li><p><strong>ax</strong> (<em>matplotlib.axes.Axes</em><em>, </em><em>optional</em>) – Target axes. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, a new figure and axes are created.</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments forwarded to
<code class="xref py py-func docutils literal notranslate"><span class="pre">networkx.draw_networkx()</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A pair <code class="docutils literal notranslate"><span class="pre">(artists,</span> <span class="pre">ax)</span></code> where <code class="docutils literal notranslate"><span class="pre">artists</span></code> is the object returned by
<code class="docutils literal notranslate"><span class="pre">networkx.draw_networkx</span></code> (often <code class="docutils literal notranslate"><span class="pre">None</span></code>) and <code class="docutils literal notranslate"><span class="pre">ax</span></code> is the axes
used for drawing.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Link to this heading"></a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Alexander S. Fox.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>